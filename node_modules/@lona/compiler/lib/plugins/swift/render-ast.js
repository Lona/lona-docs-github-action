"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const color_1 = __importDefault(require("color"));
const printer_1 = require("../../utils/printer");
const utils_1 = require("../../utils");
const SwiftAST = __importStar(require("./swift-ast"));
const printerOptions = { printWidth: 120, tabWidth: 2, useTabs: false };
const reservedWords = ['true', 'false', 'default', 'case', 'break'];
const stringWithSafeIdentifier = (id) => {
    if (/^\d/.test(id)) {
        return '_' + id;
    }
    else if (reservedWords.indexOf(id) !== -1) {
        return '`' + id + '`';
    }
    else {
        return id;
    }
};
function nodeWithSafeIdentifier(id) {
    if (id.type === 'SwiftIdentifier') {
        if (/$\d/.test(id.data)) {
            return {
                type: 'SwiftIdentifier',
                data: `_${id.data}`,
            };
        }
        return {
            type: 'SwiftIdentifier',
            data: stringWithSafeIdentifier(id.data),
        };
    }
    return {
        type: 'SwiftIdentifier',
        data: '$ Bad call to nodeWithSafeIdentifier',
    };
}
function parseColorDefault(color, fallback) {
    let parsed = color_1.default(color);
    if (!parsed) {
        parsed = color_1.default(fallback);
    }
    if (!parsed) {
        return { r: 0, g: 0, b: 0, a: 0 };
    }
    return {
        r: parsed.red(),
        g: parsed.green(),
        b: parsed.blue(),
        a: parsed.alpha(),
    };
}
function renderDeclarationModifier(node) {
    switch (node) {
        case SwiftAST.DeclarationModifier.ClassModifier:
            return 'class';
        case SwiftAST.DeclarationModifier.ConvenienceModifier:
            return 'convenience';
        case SwiftAST.DeclarationModifier.DynamicModifier:
            return 'dynamic';
        case SwiftAST.DeclarationModifier.FileprivateModifier:
            return 'fileprivate';
        case SwiftAST.DeclarationModifier.FinalModifier:
            return 'final';
        case SwiftAST.DeclarationModifier.InfixModifier:
            return 'infix';
        case SwiftAST.DeclarationModifier.InternalModifier:
            return 'internal';
        case SwiftAST.DeclarationModifier.LazyModifier:
            return 'lazy';
        case SwiftAST.DeclarationModifier.MutatingModifier:
            return 'mutating';
        case SwiftAST.DeclarationModifier.NonmutatingModifier:
            return 'nonmutating';
        case SwiftAST.DeclarationModifier.OpenModifier:
            return 'open';
        case SwiftAST.DeclarationModifier.OptionalModifier:
            return 'optional';
        case SwiftAST.DeclarationModifier.OverrideModifier:
            return 'override';
        case SwiftAST.DeclarationModifier.PostfixModifier:
            return 'postfix';
        case SwiftAST.DeclarationModifier.PrefixModifier:
            return 'prefix';
        case SwiftAST.DeclarationModifier.PrivateModifier:
            return 'private';
        case SwiftAST.DeclarationModifier.PublicModifier:
            return 'public';
        case SwiftAST.DeclarationModifier.RequiredModifier:
            return 'required';
        case SwiftAST.DeclarationModifier.StaticModifier:
            return 'static';
        case SwiftAST.DeclarationModifier.UnownedModifier:
            return 'unowned';
        case SwiftAST.DeclarationModifier.UnownedSafeModifier:
            return 'unownedsafe';
        case SwiftAST.DeclarationModifier.UnownedUnsafeModifier:
            return 'unownedunsafe';
        case SwiftAST.DeclarationModifier.WeakModifier:
            return 'weak';
    }
}
function render(ast, options) {
    switch (ast.type) {
        case 'SwiftIdentifier':
            return ast.data;
        case 'LiteralExpression':
            return renderLiteral(ast.data, options);
        case 'MemberExpression':
            return printer_1.group(printer_1.indent(printer_1.join(ast.data.map(x => render(x, options)), [printer_1.builders.softline, '.'])));
        case 'TupleExpression':
            return printer_1.builders.concat(['(']
                .concat(printer_1.group(printer_1.indent(printer_1.join(ast.data.map(x => render(x, options)), [',', printer_1.builders.line]))))
                .concat([')']));
        case 'BinaryExpression': {
            if (ast.data.right.type === 'LiteralExpression' &&
                ast.data.right.data.type === 'Array') {
                return printer_1.group([
                    render(ast.data.left, options),
                    ' ',
                    ast.data.operator,
                    ' ',
                    render(ast.data.right, options),
                ]);
            }
            return printer_1.group([
                render(ast.data.left, options),
                ' ',
                ast.data.operator,
                printer_1.indent([printer_1.builders.line, render(ast.data.right, options)]),
            ]);
        }
        case 'PrefixExpression': {
            if (ast.data.expression.type === 'LiteralExpression' ||
                ast.data.expression.type === 'SwiftIdentifier' ||
                ast.data.expression.type === 'MemberExpression') {
                return printer_1.builders.concat([
                    ast.data.operator,
                    render(ast.data.expression, options),
                ]);
            }
            return printer_1.group([
                ast.data.operator,
                '(',
                printer_1.builders.softline,
                render(ast.data.expression, options),
                printer_1.builders.softline,
                ')',
            ]);
        }
        case 'TryExpression': {
            const operator = ast.data.forced && !ast.data.optional
                ? 'try!'
                : !ast.data.forced && ast.data.optional
                    ? 'try?'
                    : 'try';
            return printer_1.builders.concat([
                operator,
                printer_1.builders.line,
                render(ast.data.expression, options),
            ]);
        }
        case 'ClassDeclaration': {
            const maybeFinal = ast.data.isFinal
                ? printer_1.builders.concat(['final', printer_1.builders.line])
                : '';
            const maybeModifier = ast.data.modifier
                ? printer_1.builders.concat([
                    renderDeclarationModifier(ast.data.modifier),
                    printer_1.builders.line,
                ])
                : '';
            const maybeInherits = ast.data.inherits.length
                ? printer_1.builders.concat([
                    ': ',
                    printer_1.builders.join(', ', ast.data.inherits.map(x => renderTypeAnnotation(x, options))),
                ])
                : '';
            const opening = printer_1.group([
                maybeModifier,
                maybeFinal,
                'class',
                printer_1.builders.line,
                ast.data.name,
                maybeInherits,
                printer_1.builders.line,
                '{',
            ]);
            const closing = printer_1.builders.concat([printer_1.builders.hardline, '}']);
            return printer_1.builders.concat([
                opening,
                printer_1.indent(printer_1.prefixAll(ast.data.body.map(x => render(x, options)), printer_1.builders.hardline)),
                closing,
            ]);
        }
        case 'StructDeclaration': {
            /* Copied from ClassDeclaration */
            const maybeModifier = ast.data.modifier
                ? printer_1.builders.concat([
                    renderDeclarationModifier(ast.data.modifier),
                    printer_1.builders.line,
                ])
                : '';
            const maybeInherits = ast.data.inherits.length
                ? printer_1.builders.concat([
                    ': ',
                    printer_1.join(ast.data.inherits.map(x => renderTypeAnnotation(x, options)), ', '),
                ])
                : '';
            const opening = printer_1.group([
                maybeModifier,
                'struct',
                printer_1.builders.line,
                ast.data.name,
                maybeInherits,
                printer_1.builders.line,
                '{',
            ]);
            const closing = printer_1.builders.concat([printer_1.builders.hardline, '}']);
            return printer_1.builders.concat([
                opening,
                printer_1.indent(printer_1.prefixAll(ast.data.body.map(x => render(x, options)), printer_1.builders.hardline)),
                closing,
            ]);
        }
        case 'ExtensionDeclaration': {
            /* Copied from ClassDeclaration */
            /* TODO: Where */
            const maybeModifier = ast.data.modifier
                ? printer_1.builders.concat([
                    renderDeclarationModifier(ast.data.modifier),
                    printer_1.builders.line,
                ])
                : '';
            const maybeProtocols = ast.data.protocols.length
                ? printer_1.builders.concat([
                    ': ',
                    printer_1.join(ast.data.protocols.map(x => renderTypeAnnotation(x, options)), ', '),
                ])
                : '';
            const opening = printer_1.group([
                maybeModifier,
                'struct',
                printer_1.builders.line,
                ast.data.name,
                maybeProtocols,
                printer_1.builders.line,
                '{',
            ]);
            const closing = printer_1.builders.concat([printer_1.builders.hardline, '}']);
            return printer_1.builders.concat([
                opening,
                printer_1.indent(printer_1.prefixAll(ast.data.body.map(x => render(x, options)), printer_1.builders.hardline)),
                closing,
            ]);
        }
        case 'EnumDeclaration': {
            /* Copied from ClassDeclaration */
            const maybeIndirect = ast.data.isIndirect
                ? printer_1.builders.concat(['indirect', printer_1.builders.line])
                : '';
            const maybeModifier = ast.data.modifier
                ? printer_1.builders.concat([
                    renderDeclarationModifier(ast.data.modifier),
                    printer_1.builders.line,
                ])
                : '';
            const maybeInherits = ast.data.inherits.length
                ? printer_1.builders.concat([
                    ': ',
                    printer_1.join(ast.data.inherits.map(x => renderTypeAnnotation(x, options)), ', '),
                ])
                : '';
            const opening = printer_1.group([
                maybeModifier,
                maybeIndirect,
                'struct',
                printer_1.builders.line,
                ast.data.name,
                maybeInherits,
                printer_1.builders.line,
                '{',
            ]);
            const closing = printer_1.builders.concat([printer_1.builders.hardline, '}']);
            return printer_1.builders.concat([
                opening,
                printer_1.indent(printer_1.prefixAll(ast.data.body.map(x => render(x, options)), printer_1.builders.hardline)),
                closing,
            ]);
        }
        case 'TypealiasDeclaration': {
            const maybeModifier = ast.data.modifier
                ? printer_1.builders.concat([
                    renderDeclarationModifier(ast.data.modifier),
                    printer_1.builders.line,
                ])
                : '';
            return printer_1.group([
                maybeModifier,
                'typealias',
                printer_1.builders.line,
                ast.data.name,
                printer_1.builders.line,
                '=',
                printer_1.builders.line,
                renderTypeAnnotation(ast.data.annotation, options),
            ]);
        }
        case 'ConstantDeclaration': {
            const modifiers = printer_1.join(ast.data.modifiers.map(renderDeclarationModifier), ' ');
            const maybeInit = ast.data.init
                ? printer_1.builders.concat([' = ', render(ast.data.init, options)])
                : '';
            // check if we have a public color literal declaration
            if (ast.data.pattern.type === 'IdentifierPattern' &&
                ast.data.pattern.data.identifier.type === 'SwiftIdentifier' &&
                ast.data.pattern.data.annotation &&
                ast.data.pattern.data.annotation.type === 'TypeName' &&
                ast.data.pattern.data.annotation.data === 'Color' &&
                ast.data.init &&
                ast.data.init.type === 'LiteralExpression' &&
                ast.data.init.data.type === 'Color' &&
                ast.data.modifiers.indexOf(SwiftAST.DeclarationModifier.PublicModifier) !== -1) {
                const rgba = parseColorDefault(ast.data.init.data.data, 'black');
                if (options.outputFile) {
                    Promise.all([
                        options.outputFile('./Assets.xcassets/Contents.json', JSON.stringify({
                            info: {
                                version: 1,
                                author: 'Lona',
                            },
                        }, null, '  ')),
                        options.outputFile('./Assets.xcassets/colors/Contents.json', JSON.stringify({
                            info: {
                                version: 1,
                                author: 'Lona',
                            },
                        }, null, '  ')),
                        options.outputFile(`./Assets.xcassets/colors/${ast.data.pattern.data.identifier.data}.colorset/Contents.json`, JSON.stringify({
                            info: {
                                version: 1,
                                author: 'Lona',
                            },
                            colors: [
                                {
                                    idiom: 'universal',
                                    color: {
                                        'color-space': 'srgb',
                                        components: {
                                            red: `0x${rgba.r.toString(16).toUpperCase()}`,
                                            alpha: `${rgba.a.toFixed(3)}`,
                                            blue: `0x${rgba.b.toString(16).toUpperCase()}`,
                                            green: `0x${rgba.g.toString(16).toUpperCase()}`,
                                        },
                                    },
                                },
                            ],
                        }, null, '  ')),
                    ]).catch(err => options.reporter.error(err));
                }
                else {
                    options.reporter.warn(`The output needs an xcasset file which wasn't emitted`);
                }
                return printer_1.group([
                    modifiers,
                    ast.data.modifiers.length ? ' ' : '',
                    'let ',
                    renderPattern(ast.data.pattern, options),
                    ' = ',
                    'Color(',
                    'named: ',
                    `"${ast.data.pattern.data.identifier.data}"`,
                    ')!',
                ]);
            }
            return printer_1.group([
                modifiers,
                ast.data.modifiers.length ? ' ' : '',
                'let ',
                renderPattern(ast.data.pattern, options),
                maybeInit,
            ]);
        }
        case 'VariableDeclaration': {
            const modifiers = printer_1.join(ast.data.modifiers.map(renderDeclarationModifier), ' ');
            const maybeInit = ast.data.init
                ? printer_1.builders.concat([' = ', render(ast.data.init, options)])
                : '';
            const maybeBlock = ast.data.block
                ? printer_1.builders.concat([
                    printer_1.builders.line,
                    renderInitializerBlock(ast.data.block, options),
                ])
                : '';
            return printer_1.group([
                modifiers,
                ast.data.modifiers.length ? ' ' : '',
                'var ',
                renderPattern(ast.data.pattern, options),
                maybeInit,
                maybeBlock,
            ]);
        }
        case 'Parameter':
            return printer_1.builders.concat([
                ast.data.externalName
                    ? printer_1.builders.concat([ast.data.externalName, ' '])
                    : '',
                ast.data.localName,
                ': ',
                renderTypeAnnotation(ast.data.annotation, options),
                ast.data.defaultValue
                    ? printer_1.builders.concat([' = ', render(ast.data.defaultValue, options)])
                    : '',
            ]);
        case 'InitializerDeclaration':
            return printer_1.group([
                printer_1.join(ast.data.modifiers.map(renderDeclarationModifier), ' '),
                ast.data.modifiers.length ? ' ' : '',
                'init',
                ast.data.failable || '',
                '(',
                printer_1.indent([
                    printer_1.builders.softline,
                    printer_1.join(ast.data.parameters.map(x => render(x, options)), [',', printer_1.builders.line]),
                ]),
                ')',
                ast.data.throws ? ' throws' : '',
                printer_1.builders.line,
                render({
                    type: 'CodeBlock',
                    data: {
                        statements: ast.data.body,
                    },
                }, options),
            ]);
        case 'DeinitializerDeclaration':
            return printer_1.builders.concat([
                'deinit ',
                render({
                    type: 'CodeBlock',
                    data: {
                        statements: ast.data,
                    },
                }, options),
            ]);
        case 'FunctionDeclaration':
            return printer_1.group([
                printer_1.group([
                    printer_1.builders.concat(ast.data.attributes.map(x => printer_1.builders.concat([x, ' ']))),
                    printer_1.join(ast.data.modifiers.map(renderDeclarationModifier), ' '),
                    ast.data.modifiers.length ? ' ' : '',
                    'func ',
                    ast.data.name,
                    '(',
                    printer_1.indent([
                        printer_1.builders.softline,
                        printer_1.join(ast.data.parameters.map(x => render(x, options)), [',', printer_1.builders.line]),
                    ]),
                    ')',
                    ast.data.result
                        ? printer_1.builders.concat([
                            ' -> ',
                            renderTypeAnnotation(ast.data.result, options),
                        ])
                        : '',
                    ast.data.throws ? ' throws' : '',
                ]),
                printer_1.builders.line,
                render({
                    type: 'CodeBlock',
                    data: {
                        statements: ast.data.body,
                    },
                }, options),
            ]);
        case 'ImportDeclaration':
            return printer_1.group(['import', printer_1.builders.line, ast.data]);
        case 'IfStatement':
            return printer_1.group([
                /* Line break here due to personal preference */
                /* builders.hardline, */
                'if',
                printer_1.builders.line,
                render(ast.data.condition, options),
                printer_1.builders.line,
                render({
                    type: 'CodeBlock',
                    data: { statements: ast.data.block },
                }, options),
            ]);
        case 'ForInStatement':
            return printer_1.group([
                'for',
                printer_1.builders.line,
                renderPattern(ast.data.item, options),
                printer_1.builders.line,
                'in',
                printer_1.builders.line,
                render(ast.data.collection, options),
                printer_1.builders.line,
                render({ type: 'CodeBlock', data: { statements: ast.data.block } }, options),
            ]);
        case 'WhileStatement':
            return printer_1.group([
                'while',
                printer_1.builders.line,
                render(ast.data.condition, options),
                printer_1.builders.line,
                render({ type: 'CodeBlock', data: { statements: ast.data.block } }, options),
            ]);
        case 'SwitchStatement':
            return printer_1.group([
                'while',
                printer_1.builders.line,
                render(ast.data.expression, options),
                printer_1.builders.line,
                render({ type: 'CodeBlock', data: { statements: ast.data.cases } }, options),
            ]);
        case 'CaseLabel': {
            /* Automatically add break statement if needed, for convenience */
            const statements = ast.data.statements.length >= 1
                ? ast.data.statements
                : [{ type: 'SwiftIdentifier', data: 'break' }];
            return printer_1.builders.concat([
                'case ',
                printer_1.join(ast.data.patterns.map(x => renderPattern(x, options)), [',', printer_1.builders.line]),
                ':',
                printer_1.indent(printer_1.prefixAll(statements.map(x => render(x, options)), printer_1.builders.hardline)),
            ]);
        }
        case 'DefaultCaseLabel': {
            /* Automatically add break statement if needed, for convenience */
            const statements = ast.data.statements.length >= 1
                ? ast.data.statements
                : [{ type: 'SwiftIdentifier', data: 'break' }];
            return printer_1.builders.concat([
                'default:',
                printer_1.indent(printer_1.prefixAll(statements.map(x => render(x, options)), printer_1.builders.hardline)),
            ]);
        }
        case 'ReturnStatement':
            return printer_1.group(['return', ast.data ? render(ast.data, options) : '']);
        case 'FunctionCallArgument':
            return ast.data.name
                ? printer_1.group([
                    render(ast.data.name, options),
                    ':',
                    printer_1.builders.line,
                    render(ast.data.value, options),
                ])
                : printer_1.group(render(ast.data.value, options));
        case 'FunctionCallExpression': {
            // TODO: (Mathieu): is that right?
            const endsWithLiteral = ast.data.arguments.length !== 1 ||
                ast.data.arguments[0].type !== 'FunctionCallArgument' ||
                ast.data.arguments[0].data.value.type !== 'LiteralExpression';
            const args = printer_1.builders.concat([
                endsWithLiteral ? printer_1.builders.softline : '',
                printer_1.join(ast.data.arguments.map(x => render(x, options)), [',', printer_1.builders.line]),
            ]);
            return printer_1.group([
                render(ast.data.name, options),
                '(',
                endsWithLiteral ? printer_1.indent(args) : args,
                ')',
            ]);
        }
        case 'EnumCase': {
            const name = nodeWithSafeIdentifier(ast.data.name);
            if (!ast.data.value) {
                const params = ast.data.parameters
                    ? renderTypeAnnotation(ast.data.parameters, options)
                    : '';
                return printer_1.group(['case ', render(name, options), params]);
            }
            return printer_1.group([
                'case ',
                render(name, options),
                ' = ',
                render(ast.data.value, options),
            ]);
        }
        case 'ConditionList':
            return printer_1.group(printer_1.indent(printer_1.join(ast.data.map(x => render(x, options)), [',', printer_1.builders.line])));
        case 'CaseCondition':
            return printer_1.group([
                'case ',
                renderPattern(ast.data.pattern, options),
                printer_1.builders.line,
                '=',
                printer_1.builders.line,
                render(ast.data.init, options),
            ]);
        case 'OptionalBindingCondition':
            return printer_1.group([
                ast.data.const ? 'let' : 'var',
                ' ',
                renderPattern(ast.data.pattern, options),
                printer_1.builders.line,
                '=',
                printer_1.builders.line,
                render(ast.data.init, options),
            ]);
        case 'Empty':
            return ''; // This only works if lines are added between statements...
        case 'LineComment':
            return `// ${ast.data}`;
        case 'DocComment': {
            const comment = ast.data.match(/.{1,100}/g);
            if (!comment) {
                return '///';
            }
            return comment.map(x => `/// ${x}`).join('\n');
        }
        case 'LineEndComment':
            return printer_1.builders.concat([
                render(ast.data.line, options),
                printer_1.builders.lineSuffix(` // ${ast.data.comment}`),
            ]);
        case 'CodeBlock': {
            if (!ast.data.statements.length) {
                return '{}';
            }
            if (ast.data.statements.length === 1 &&
                ast.data.statements[0].type === 'SwiftIdentifier') {
                return printer_1.builders.concat([
                    '{',
                    printer_1.builders.line,
                    render(ast.data.statements[0], options),
                    printer_1.builders.line,
                    '}',
                ]);
            }
            return printer_1.builders.concat([
                '{',
                printer_1.indent(printer_1.prefixAll(ast.data.statements.map(x => render(x, options)), printer_1.builders.hardline)),
                printer_1.builders.hardline,
                '}',
            ]);
        }
        case 'StatementListHelper':
            /* TODO: Get rid of this? */
            return printer_1.join(ast.data.map(x => render(x, options)), printer_1.builders.hardline);
        case 'TopLevelDeclaration':
            return printer_1.builders.concat([
                printer_1.join(ast.data.statements.map(x => render(x, options)), [printer_1.builders.hardline]),
                printer_1.builders.hardline,
            ]);
        default: {
            utils_1.typeNever(ast, options.reporter.warn);
            return '';
        }
    }
}
function renderLiteral(node, options) {
    switch (node.type) {
        case 'Nil':
            return 'nil';
        case 'Boolean':
            return node.data ? 'true' : 'false';
        case 'Integer':
            return `${node.data}`;
        case 'FloatingPoint':
            return `${node.data}`;
        case 'String':
            // TODO: is it just `JSON.stringify`?
            return printer_1.builders.concat(['"', node.data.replace(/"/g, '\\"'), '"']);
        case 'Color': {
            const rgba = parseColorDefault(node.data, 'black');
            const values = [
                printer_1.builders.concat(['red: ', `${rgba.r / 255}`]),
                printer_1.builders.concat(['green: ', `${rgba.g / 255}`]),
                printer_1.builders.concat(['blue: ', `${rgba.b / 255}`]),
                printer_1.builders.concat(['alpha: ', `${rgba.a}`]),
            ];
            return printer_1.group(['#colorLiteral(', printer_1.join(values, ', '), ')']);
        }
        case 'Image':
            return printer_1.group(['#imageLiteral(resourceName: "', node.data, '")']);
        case 'Array': {
            const maybeLine = node.data.length ? printer_1.builders.softline : '';
            const body = printer_1.join(node.data.map(x => render(x, options)), [',', printer_1.builders.line]);
            return printer_1.group(['[', printer_1.indent([maybeLine, body]), maybeLine, ']']);
        }
        default: {
            utils_1.assertNever(node);
        }
    }
}
function renderTypeAnnotation(node, options) {
    switch (node.type) {
        case 'TypeName':
            return node.data;
        case 'TypeIdentifier':
            return printer_1.group([
                renderTypeAnnotation(node.data.name, options),
                printer_1.builders.line,
                '.',
                printer_1.builders.line,
                renderTypeAnnotation(node.data.member, options),
            ]);
        case 'ArrayType':
            return printer_1.group(['[', renderTypeAnnotation(node.data, options), ']']);
        case 'DictionaryType':
            return printer_1.group([
                '[',
                renderTypeAnnotation(node.data.key, options),
                ': ',
                renderTypeAnnotation(node.data.value, options),
            ]);
        case 'OptionalType':
            return printer_1.group([renderTypeAnnotation(node.data, options), '?']);
        case 'TupleType':
            return printer_1.builders.concat([
                '(',
                printer_1.group(printer_1.join(node.data.map(x => x.elementName
                    ? printer_1.builders.concat([
                        `${x.elementName}: `,
                        renderTypeAnnotation(x.annotation, options),
                    ])
                    : renderTypeAnnotation(x.annotation, options)), ', ')),
                ')',
            ]);
        case 'FunctionType': {
            const args = printer_1.group(printer_1.join(node.data.arguments.map(x => renderTypeAnnotation(x, options)), ', '));
            return printer_1.group([
                '(',
                '(',
                args,
                ') -> ',
                node.data.returnType
                    ? renderTypeAnnotation(node.data.returnType, options)
                    : 'Void',
                ')',
            ]);
        }
        case 'TypeInheritanceList':
            return printer_1.group(printer_1.join(node.data.list.map(x => renderTypeAnnotation(x, options)), ', '));
        case 'ProtocolCompositionType':
            return printer_1.group(printer_1.join(node.data.map(x => renderTypeAnnotation(x, options)), ' & '));
        default: {
            utils_1.assertNever(node);
        }
    }
}
function renderPattern(node, options) {
    switch (node.type) {
        case 'WildcardPattern':
            return '_';
        case 'IdentifierPattern': {
            const name = nodeWithSafeIdentifier(node.data.identifier);
            if (!node.data.annotation) {
                return render(name, options);
            }
            return printer_1.builders.concat([
                render(name, options),
                ': ',
                renderTypeAnnotation(node.data.annotation, options),
            ]);
        }
        case 'ValueBindingPattern':
            return printer_1.group([
                node.data.kind,
                printer_1.builders.line,
                renderPattern(node.data.pattern, options),
            ]);
        case 'TuplePattern':
            return printer_1.group([
                '(',
                printer_1.join(node.data.map(x => renderPattern(x, options)), ', '),
                ')',
            ]);
        case 'OptionalPattern':
            return printer_1.builders.concat([renderPattern(node.data.value, options), '?']);
        case 'ExpressionPattern':
            return render(node.data.value, options);
        case 'EnumCasePattern': {
            const maybeTypeIdentifier = node.data.typeIdentifier || '';
            const maybePattern = node.data.tuplePattern
                ? renderPattern(node.data.tuplePattern, options)
                : '';
            return printer_1.group([
                maybeTypeIdentifier,
                '.',
                stringWithSafeIdentifier(node.data.caseName),
                maybePattern,
            ]);
        }
        default: {
            utils_1.assertNever(node);
        }
    }
}
const isSingleLine = (x) => x.length === 1 && x[0].type !== 'IfStatement';
const renderStatements = (x, options) => isSingleLine(x)
    ? printer_1.builders.concat([
        '{ ',
        printer_1.builders.concat(x.map(x => render(x, options))),
        ' }',
    ])
    : render({ type: 'CodeBlock', data: { statements: x } }, options);
function renderInitializerBlock(node, options) {
    switch (node.type) {
        case 'GetterBlock':
            return render({ type: 'CodeBlock', data: { statements: node.data } }, options);
        case 'GetterSetterBlock':
            return printer_1.builders.concat([
                '{',
                printer_1.indent([
                    printer_1.builders.hardline,
                    'get ',
                    renderStatements(node.data.get, options),
                    printer_1.builders.hardline,
                    'set ',
                    renderStatements(node.data.set, options),
                ]),
                printer_1.builders.hardline,
                '}',
            ]);
        case 'WillSetDidSetBlock': {
            /* Special case some single-statement willSet/didSet and render them in a single line
               since they are common in our generated code and are easier to read than multiline */
            const willSet = node.data.willSet
                ? printer_1.builders.concat([
                    'willSet ',
                    renderStatements(node.data.willSet, options),
                ])
                : '';
            const didSet = node.data.didSet
                ? printer_1.builders.concat([
                    'didSet ',
                    renderStatements(node.data.didSet, options),
                ])
                : '';
            if (!node.data.willSet && !node.data.didSet) {
                return '';
            }
            if (!node.data.willSet && node.data.didSet) {
                if (isSingleLine(node.data.didSet)) {
                    return printer_1.group(printer_1.join(['{', printer_1.indent(didSet), '}'], printer_1.builders.line));
                }
                return printer_1.builders.concat([
                    '{',
                    printer_1.indent([printer_1.builders.hardline, didSet]),
                    printer_1.builders.hardline,
                    '}',
                ]);
            }
            if (node.data.willSet && !node.data.didSet) {
                if (isSingleLine(node.data.willSet)) {
                    return printer_1.group(printer_1.join(['{', printer_1.indent(willSet), '}'], printer_1.builders.line));
                }
                return printer_1.builders.concat([
                    '{',
                    printer_1.indent([printer_1.builders.hardline, willSet]),
                    printer_1.builders.hardline,
                    '}',
                ]);
            }
            return printer_1.builders.concat([
                '{',
                printer_1.indent([printer_1.builders.hardline, willSet, printer_1.builders.hardline, didSet]),
                printer_1.builders.hardline,
                '}',
            ]);
        }
        default: {
            utils_1.assertNever(node);
        }
    }
}
function toString(ast, options) {
    return printer_1.print(render(ast, options), printerOptions);
}
exports.default = toString;
