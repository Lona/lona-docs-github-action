"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const TokenValue = __importStar(require("./token-value"));
const utils_1 = require("../../utils");
exports.convertDeclaration = (declaration, helpers) => {
    if (!helpers.evaluationContext) {
        return undefined;
    }
    if (declaration.type !== 'variable' || !declaration.data.initializer) {
        return undefined;
    }
    const logicValue = helpers.evaluationContext.evaluate(declaration.data.initializer.data.id);
    const tokenValue = TokenValue.create(logicValue);
    if (!tokenValue) {
        return undefined;
    }
    return { qualifiedName: [declaration.data.name.name], value: tokenValue };
};
exports.convert = (node, helpers) => {
    let declarations;
    if ('type' in node && node.type === 'program') {
        declarations = node.data.block
            .map(x => (x.type === 'declaration' ? x.data.content : undefined))
            .filter(utils_1.nonNullable);
    }
    else if ('type' in node && node.type === 'topLevelDeclarations') {
        declarations = node.data.declarations;
    }
    else {
        helpers.reporter.warn('Unhandled top-level syntaxNode type');
        return [];
    }
    return declarations
        .map(x => exports.convertDeclaration(x, helpers))
        .filter(utils_1.nonNullable);
};
