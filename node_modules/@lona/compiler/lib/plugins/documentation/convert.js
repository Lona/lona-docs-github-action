"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const serialization = __importStar(require("@lona/serialization"));
const convert_1 = require("../tokens/convert");
const utils_1 = require("../../utils");
let tokenNameElement = (kind, content) => `<span class="lona-token-name lona-token-name-${kind}">${content}</span>`;
let tokenValueElement = (kind, content) => `<span class="lona-token-value lona-token-value-${kind}">${content}</span>`;
let tokenContainerElement = (kind, content) => `<div class="lona-token lona-token-${kind}">
  ${content.join('\n  ')}
</div>`;
let tokenDetailsElement = (kind, content) => `<div class="lona-token-details lona-token-details-${kind}">
    ${content.join('\n    ')}
  </div>`;
let tokenPreviewElement = (kind, data) => `<div  class="lona-token-preview lona-token-preview-${kind}" ${Object.keys(data)
    .map(k => (data[k] ? `data-${k}="${data[k]}"` : undefined))
    .filter(x => !!x)
    .join(' ')}></div>`;
const convertToken = (token) => {
    const tokenName = token.qualifiedName.join('.');
    if (token.value.type === 'color') {
        return tokenContainerElement(token.value.type, [
            tokenPreviewElement(token.value.type, { color: token.value.value.css }),
            tokenDetailsElement(token.value.type, [
                tokenNameElement(token.value.type, tokenName),
                tokenValueElement(token.value.type, token.value.value.css),
            ]),
        ]);
    }
    if (token.value.type === 'shadow') {
        return tokenContainerElement(token.value.type, [
            tokenPreviewElement(token.value.type, {
                x: `${token.value.value.x}`,
                y: `${token.value.value.y}`,
                blur: `${token.value.value.blur}`,
                radius: `${token.value.value.radius}`,
                color: `${token.value.value.color.css}`,
            }),
            tokenDetailsElement(token.value.type, [
                tokenNameElement(token.value.type, tokenName),
                tokenValueElement(token.value.type, `${token.value.value.x}px ${token.value.value.y}px ${token.value.value.blur}px ${token.value.value.radius}px ${token.value.value.color.css}`),
            ]),
        ]);
    }
    if (token.value.type === 'textStyle') {
        const { value } = token.value;
        return tokenContainerElement(token.value.type, [
            tokenPreviewElement(token.value.type, {
                fontFamily: value.fontFamily,
                fontWeight: value.fontWeight,
                fontSize: typeof value.fontSize !== 'undefined'
                    ? `${value.fontSize}`
                    : undefined,
                lineHeight: typeof value.lineHeight !== 'undefined'
                    ? `${value.lineHeight}`
                    : undefined,
                letterSpacing: typeof value.letterSpacing !== 'undefined'
                    ? `${value.letterSpacing}`
                    : undefined,
                color: value.color ? `${value.color.css}` : undefined,
            }),
            tokenDetailsElement(token.value.type, [
                tokenNameElement(token.value.type, tokenName),
                tokenValueElement(token.value.type, `${value.fontFamily} ${value.fontWeight}${typeof value.fontSize !== 'undefined' ? ` ${value.fontSize}px` : ''}${typeof value.lineHeight !== 'undefined'
                    ? ` ${value.lineHeight}px`
                    : ''}${typeof value.letterSpacing !== 'undefined'
                    ? ` ${value.letterSpacing}px`
                    : ''}${value.color ? ` ${value.color.css}` : ''}`),
            ]),
        ]);
    }
    utils_1.assertNever(token.value);
};
exports.convert = (root, helpers) => {
    return root.children
        .map(child => {
        if (child.type === 'code' && child.data.parsed) {
            return child.data.parsed.data.declarations
                .map(x => convert_1.convertDeclaration(x, helpers))
                .filter(utils_1.nonNullable)
                .map(convertToken)
                .join('');
        }
        return serialization.printMdxNode(child);
    })
        .join('\n\n');
};
