"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var binaryOperator;
(function (binaryOperator) {
    binaryOperator[binaryOperator["Eq"] = 0] = "Eq";
    binaryOperator[binaryOperator["LooseEq"] = 1] = "LooseEq";
    binaryOperator[binaryOperator["Neq"] = 2] = "Neq";
    binaryOperator[binaryOperator["LooseNeq"] = 3] = "LooseNeq";
    binaryOperator[binaryOperator["Gt"] = 4] = "Gt";
    binaryOperator[binaryOperator["Gte"] = 5] = "Gte";
    binaryOperator[binaryOperator["Lt"] = 6] = "Lt";
    binaryOperator[binaryOperator["Lte"] = 7] = "Lte";
    binaryOperator[binaryOperator["Plus"] = 8] = "Plus";
    binaryOperator[binaryOperator["Minus"] = 9] = "Minus";
    binaryOperator[binaryOperator["And"] = 10] = "And";
    binaryOperator[binaryOperator["Or"] = 11] = "Or";
    binaryOperator[binaryOperator["Noop"] = 12] = "Noop";
})(binaryOperator = exports.binaryOperator || (exports.binaryOperator = {}));
// /* Children are mapped first */
// let rec map = (f: node => node, node) =>
//   switch (node) {
//   | Return(value) => f(Return(value |> map(f)))
//   | Literal(_)
//   | StringLiteral(_)
//   | Identifier(_)
//   | ImportDeclaration(_)
//   | ImportSpecifier(_)
//   | JSXExpressionContainer(value) =>
//     f(JSXExpressionContainer(value |> map(f)))
//   | JSXSpreadAttribute(value) => JSXSpreadAttribute(f(value))
//   | SpreadElement(value) => SpreadElement(f(value))
//   | ClassDeclaration(o) =>
//     f(
//       ClassDeclaration({
//         id: o.id,
//         superClass: o.superClass,
//         body: o.body |> List.map(map(f)),
//       }),
//     )
//   | MethodDefinition(o) =>
//     f(MethodDefinition({key: o.key, value: o.value |> map(f)}))
//   | FunctionExpression(o) =>
//     f(
//       FunctionExpression({
//         id: o.id,
//         params: o.params |> List.map(map(f)),
//         body: o.body |> List.map(map(f)),
//       }),
//     )
//   | ArrowFunctionExpression(o) =>
//     f(
//       ArrowFunctionExpression({
//         id: o.id,
//         params: o.params |> List.map(map(f)),
//         body: o.body |> List.map(map(f)),
//       }),
//     )
//   | CallExpression(o) =>
//     f(
//       CallExpression({
//         callee: o.callee |> map(f),
//         arguments: o.arguments |> List.map(map(f)),
//       }),
//     )
//   | JSXAttribute(o) =>
//     f(JSXAttribute({name: o.name, value: o.value |> map(f)}))
//   | JSXElement(o) =>
//     f(
//       JSXElement({
//         tag: o.tag,
//         attributes: o.attributes |> List.map(map(f)),
//         content: o.content |> List.map(map(f)),
//       }),
//     )
//   | VariableDeclaration(value) => f(VariableDeclaration(value |> map(f)))
//   | AssignmentExpression(o) =>
//     f(
//       AssignmentExpression({
//         left: o.left |> map(f),
//         right: o.right |> map(f),
//       }),
//     )
//   | BinaryExpression(o) =>
//     f(
//       BinaryExpression({
//         left: o.left |> map(f),
//         operator: o.operator,
//         right: o.right |> map(f),
//       }),
//     )
//   | UnaryExpression(o) =>
//     f(
//       UnaryExpression({
//         prefix: o.prefix,
//         operator: o.operator,
//         argument: o.argument |> map(f),
//       }),
//     )
//   | IfStatement(o) =>
//     f(
//       IfStatement({
//         test: o.test |> map(f),
//         consequent: o.consequent |> List.map(map(f)),
//         alternate: o.alternate |> List.map(map(f)),
//       }),
//     )
//   | ConditionalExpression(o) =>
//     f(
//       ConditionalExpression({
//         test: o.test |> map(f),
//         consequent: o.consequent |> map(f),
//         alternate: o.alternate |> map(f),
//       }),
//     )
//   | ArrayLiteral(body) => f(ArrayLiteral(body |> List.map(map(f))))
//   | ObjectLiteral(body) => f(ObjectLiteral(body |> List.map(map(f))))
//   | Property(o) =>
//     f(
//       Property({
//         key: o.key |> map(f),
//         value:
//           switch (o.value) {
//           | Some(value) => Some(value |> map(f))
//           | None => None
//           },
//       }),
//     )
//   | ExportDefaultDeclaration(value) =>
//     f(ExportDefaultDeclaration(value |> map(f)))
//   | ExportNamedDeclaration(value) =>
//     f(ExportNamedDeclaration(value |> map(f)))
//   | Block(body) => f(Block(body |> List.map(map(f))))
//   | Program(body) => f(Program(body |> List.map(map(f))))
//   | LineEndComment(o) =>
//     f(LineEndComment({comment: o.comment, line: o.line |> map(f)}))
//   | Empty
//   | Unknown => f(node)
//   };
// /* Takes an expression like `a === true` and converts it to `a` */
// let optimizeTruthyBinaryExpression = node => {
//   let booleanValue = sub =>
//     switch (sub) {
//     | Literal(value) => value.data |> Json.Decode.optional(Json.Decode.bool)
//     | _ => (None: option(bool))
//     };
//   switch (node) {
//   | BinaryExpression(o) =>
//     switch (booleanValue(o.left), o.operator, booleanValue(o.right)) {
//     | (_, Eq, Some(true)) => o.left
//     | (Some(true), Eq, _) => o.right
//     | _ => node
//     }
//   | _ => node
//   };
// };
// /* Renamed "layer.View.backgroundColor" to something JS-safe and nice looking */
// let renameIdentifiers = node =>
//   switch (node) {
//   | Identifier(["parameters", ...tail]) =>
//     Identifier([
//       "this",
//       "props",
//       ...tail |> List.map(Format.safeVariableName),
//     ])
//   | Identifier(["layers", ...tail]) =>
//     Identifier([
//       tail |> List.map(Format.safeVariableName) |> Format.joinWith("$"),
//     ])
//   | Identifier(parts) =>
//     Identifier(parts |> List.map(Format.safeVariableName))
//   | _ => node
//   };
// let optimize = node => node |> map(optimizeTruthyBinaryExpression);
// let prepareForRender = node => node |> map(renameIdentifiers);
