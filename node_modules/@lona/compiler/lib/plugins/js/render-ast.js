"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const printer_1 = require("../../utils/printer");
const utils_1 = require("../../utils");
const JSAST = __importStar(require("./js-ast"));
const printerOptions = { printWidth: 120, tabWidth: 2, useTabs: false };
let renderBinaryOperator = (x) => {
    switch (x) {
        case JSAST.binaryOperator.Eq:
            return '===';
        case JSAST.binaryOperator.LooseEq:
            return '==';
        case JSAST.binaryOperator.Neq:
            return '!==';
        case JSAST.binaryOperator.LooseNeq:
            return '!=';
        case JSAST.binaryOperator.Gt:
            return '>';
        case JSAST.binaryOperator.Gte:
            return '>=';
        case JSAST.binaryOperator.Lt:
            return '<';
        case JSAST.binaryOperator.Lte:
            return '<=';
        case JSAST.binaryOperator.Plus:
            return '+';
        case JSAST.binaryOperator.Minus:
            return '-';
        case JSAST.binaryOperator.And:
            return '&&';
        case JSAST.binaryOperator.Or:
            return '||';
        case JSAST.binaryOperator.Noop:
            return '';
    }
};
const smartPath = (path, pathNode) => pathNode === path[0]
    ? pathNode
    : /\W/g.test(pathNode)
        ? `['${pathNode}']`
        : printer_1.builders.concat([printer_1.builders.softline, '.', pathNode]);
let counter = 0;
const importName = () => {
    return `__lona_import_${counter++}`;
};
function render(ast, options) {
    switch (ast.type) {
        case 'InterfaceDeclaration':
            return printer_1.builders.concat([
                'interface ',
                ast.data.data.identifier,
                renderTypeParameters(ast.data.data.typeParameters),
                ' ',
                renderObjectType(ast.data.data.objectType),
            ]);
        case 'TypeAliasDeclaration':
            return printer_1.builders.concat([
                'type ',
                ast.data.data.identifier,
                renderTypeParameters(ast.data.data.typeParameters),
                ' = ',
                renderType(ast.data.data.type),
            ]);
        case 'Identifier':
            return printer_1.group(ast.data.map(pathNode => smartPath(ast.data, pathNode)));
        case 'Literal':
            return renderLiteral(ast.data, options);
        case 'VariableDeclaration':
            return printer_1.group(['var ', render(ast.data, options)]);
        case 'AssignmentExpression':
            return printer_1.builders.fill([
                printer_1.group([render(ast.data.left, options), printer_1.builders.line, '=']),
                ' ',
                render(ast.data.right, options),
            ]);
        case 'BinaryExpression':
            return printer_1.group([
                render(ast.data.left, options),
                ' ',
                renderBinaryOperator(ast.data.operator),
                printer_1.builders.line,
                render(ast.data.right, options),
            ]);
        case 'UnaryExpression':
            return ast.data.prefix
                ? printer_1.builders.concat([
                    ast.data.operator,
                    render(ast.data.argument, options),
                ])
                : printer_1.builders.concat([
                    render(ast.data.argument, options),
                    ast.data.operator,
                ]);
        case 'IfStatement': {
            const ifPart = printer_1.builders.concat([
                printer_1.group([
                    'if (',
                    printer_1.indent([
                        printer_1.builders.softline,
                        render(ast.data.test, options),
                        printer_1.builders.softline,
                        ') ',
                    ]),
                ]),
                renderBlockBody(ast.data.consequent, true, options),
            ]);
            if (ast.data.alternate.length === 0) {
                return ifPart;
            }
            if (ast.data.alternate.length === 1 &&
                ast.data.alternate[0].type === 'IfStatement') {
                return printer_1.builders.concat([
                    ifPart,
                    ' else ',
                    render(ast.data.alternate[0], options),
                ]);
            }
            return printer_1.builders.concat([
                ifPart,
                ' else ',
                renderBlockBody(ast.data.alternate, true, options),
            ]);
        }
        case 'WhileStatement': {
            return printer_1.builders.concat([
                printer_1.group([
                    'while (',
                    printer_1.indent([
                        printer_1.builders.softline,
                        render(ast.data.test, options),
                        printer_1.builders.softline,
                        ') ',
                    ]),
                ]),
                renderBlockBody(ast.data.body, true, options),
            ]);
        }
        case 'ConditionalExpression':
            return printer_1.group([
                '(',
                printer_1.indent([
                    printer_1.builders.line,
                    render(ast.data.test, options),
                    printer_1.indent([
                        printer_1.builders.line,
                        '? ',
                        render(ast.data.consequent, options),
                        printer_1.builders.line,
                        ': ',
                        render(ast.data.alternate, options),
                    ]),
                ]),
                printer_1.builders.line,
                ')',
            ]);
        case 'ImportDeclaration': {
            const specifiers = ast.data.specifiers.filter(x => x.type === 'ImportSpecifier');
            if (specifiers.length <= 0) {
                return '';
            }
            const tempImportName = importName();
            const namedImports = printer_1.join(specifiers.map(x => printer_1.group([
                'var',
                ' ',
                x.data.local || x.data.imported,
                ' ',
                '=',
                ' ',
                `${tempImportName}.${x.data.imported}`,
                ';',
            ])), printer_1.builders.line);
            return printer_1.group([
                printer_1.group([
                    'var',
                    ' ',
                    tempImportName,
                    ' ',
                    '=',
                    ' ',
                    printer_1.builders.fill(['require', '(', `"${ast.data.source}"`, ')']),
                    ';',
                ]),
                printer_1.builders.hardline,
                printer_1.group(namedImports),
                printer_1.builders.line,
            ]);
        }
        case 'ClassDeclaration': {
            const decl = ast.data.superClass
                ? ['class', ast.data.id, 'extends', ast.data.superClass]
                : ['class', ast.data.id];
            return printer_1.builders.concat([
                printer_1.group([printer_1.join(decl, printer_1.builders.line), ' {']),
                printer_1.indent(printer_1.prefixAll(ast.data.body.map(x => render(x, options)), printer_1.builders.hardline)),
                printer_1.builders.hardline,
                '}',
            ]);
        }
        case 'MethodDefinition':
            return printer_1.group([ast.data.key, render(ast.data.value, options)]);
        case 'FunctionExpression': {
            /* TODO: o.id */
            const parameterList = printer_1.join(ast.data.params.map(x => render(x, options)), printer_1.builders.line);
            return printer_1.group([
                '(',
                parameterList,
                ') ',
                renderBlockBody(ast.data.body, false, options),
            ]);
        }
        case 'ArrowFunctionExpression': {
            const parameterList = printer_1.join(ast.data.params.map(x => render(x, options)), printer_1.builders.line);
            if (ast.data.body.length === 1 && ast.data.body[0].type === 'Return') {
                if (ast.data.body[0].data.type === 'Literal' &&
                    ast.data.body[0].data.data.type === 'Object') {
                    return printer_1.builders.concat([
                        printer_1.group(['(', parameterList, ') => (']),
                        renderLiteral(ast.data.body[0].data.data, options),
                        ')',
                    ]);
                }
                return printer_1.builders.concat([
                    printer_1.group(['(', parameterList, ') => (']),
                    printer_1.indent([printer_1.builders.line, render(ast.data.body[0].data, options)]),
                    printer_1.builders.line,
                    ')',
                ]);
            }
            return printer_1.group([
                '(',
                parameterList,
                ') => ',
                renderBlockBody(ast.data.body, false, options),
            ]);
        }
        case 'CallExpression': {
            const parameterList = printer_1.join(ast.data.arguments.map(x => render(x, options)), ', ');
            return printer_1.builders.fill([
                render(ast.data.callee, options),
                '(',
                parameterList,
                ')',
            ]);
        }
        case 'MemberExpression':
            return printer_1.builders.concat([
                render(ast.data.expression, options),
                printer_1.builders.softline,
                '.',
                ast.data.memberName,
            ]);
        case 'Return':
            return printer_1.group([
                printer_1.group('return '),
                printer_1.builders.ifBreak('(', ''),
                printer_1.indent([printer_1.builders.softline, render(ast.data, options)]),
                printer_1.builders.softline,
                printer_1.builders.ifBreak(')', ''),
                ';',
            ]);
        case 'JSXAttribute':
            return printer_1.builders.concat([
                ast.data.name,
                '={',
                render(ast.data.value, options),
                '}',
            ]);
        case 'JSXElement': {
            const hasAttributes = ast.data.attributes.length > 0;
            const hasChildren = ast.data.content.length > 0;
            const openingContent = printer_1.join(ast.data.attributes.map(x => render(x, options)), printer_1.builders.line);
            const openingTag = printer_1.group([
                '<',
                ast.data.tag,
                hasAttributes
                    ? printer_1.builders.concat([
                        printer_1.indent([printer_1.builders.line, openingContent]),
                        printer_1.builders.softline,
                    ])
                    : '',
                hasChildren ? '>' : printer_1.builders.concat([printer_1.builders.line, '/>']),
            ]);
            if (!hasChildren) {
                return openingTag;
            }
            const closingTag = printer_1.group(['</', ast.data.tag, '>']);
            const children = printer_1.indent([
                printer_1.builders.line,
                printer_1.join(ast.data.content.map(x => render(x, options)), printer_1.builders.line),
            ]);
            return printer_1.builders.concat([openingTag, children, printer_1.builders.line, closingTag]);
        }
        case 'JSXExpressionContainer':
            return printer_1.group([
                '{',
                printer_1.indent([printer_1.builders.softline, render(ast.data, options)]),
                printer_1.builders.softline,
                '}',
            ]);
        case 'JSXSpreadAttribute':
            return printer_1.builders.concat(['{...', render(ast.data, options), '}']);
        case 'SpreadElement':
            return printer_1.builders.concat(['...', render(ast.data, options)]);
        case 'Property': {
            const maybeValue = ast.data.value
                ? printer_1.builders.concat([': ', render(ast.data.value, options)])
                : '';
            if (ast.data.key.type === 'Identifier') {
                return /\W/g.test(ast.data.key.data[0])
                    ? printer_1.group([`'${ast.data.key.data[0]}'`, maybeValue])
                    : printer_1.group([ast.data.key.data[0], maybeValue]);
            }
            return printer_1.group([render(ast.data.key, options), maybeValue]);
        }
        case 'ExportNamedDeclaration':
            return printer_1.group([
                printer_1.group(['var ', render(ast.data, options), ';']),
                printer_1.builders.hardline,
                printer_1.group([
                    'module.exports.',
                    render(ast.data.data.left, options),
                    ' ',
                    '=',
                    ' ',
                    render(ast.data.data.left, options),
                    ';',
                ]),
            ]);
        case 'Program':
            return printer_1.join(ast.data.map(x => render(x, options)), printer_1.builders.hardline);
        case 'LineEndComment':
            return printer_1.builders.concat([
                render(ast.data.line, options),
                printer_1.builders.lineSuffix(` // ${ast.data.comment}`),
            ]);
        case 'Unknown':
        case 'Empty':
            return '';
        default: {
            utils_1.typeNever(ast, options.reporter.warn);
            return '';
        }
    }
}
const renderLiteral = (literal, options) => {
    switch (literal.type) {
        case 'Image':
        case 'Color':
        case 'String':
        case 'Number':
        case 'Boolean':
            return JSON.stringify(literal.data);
        case 'Null':
            return `null`;
        case 'Undefined':
            return 'undefined';
        case 'Array': {
            const maybeLine = literal.data.length > 0 ? printer_1.builders.line : '';
            const body = printer_1.join(literal.data.map(x => render(x, options)), [',', printer_1.builders.line]);
            return printer_1.group(['[', printer_1.indent([maybeLine, body]), maybeLine, ']']);
        }
        case 'Object': {
            const maybeLine = literal.data.length > 0 ? printer_1.builders.line : '';
            const body = printer_1.join(literal.data.map(x => render(x, options)), [',', printer_1.builders.line]);
            return printer_1.group(['{', printer_1.indent([maybeLine, body]), maybeLine, '}']);
        }
        default: {
            utils_1.assertNever(literal);
        }
    }
};
const renderTypeParameters = (parameters) => {
    if (!parameters.length) {
        return '';
    }
    return printer_1.builders.concat([
        '<',
        printer_1.join(parameters.map(x => renderType(x)), printer_1.builders.line),
        '>',
    ]);
};
const renderObjectType = (objectType) => {
    const renderedMembers = printer_1.join(objectType.members.map(x => {
        if (x.type === 'PropertySignature') {
            if (x.data.type) {
                if (x.data.type.type === 'TypeReference') {
                    return printer_1.builders.concat([
                        x.data.name,
                        '?: ',
                        renderType(x.data.type.data.arguments[0]),
                    ]);
                }
                return printer_1.builders.concat([x.data.name, '? ', renderType(x.data.type)]);
            }
            return x.data.name;
        }
        utils_1.assertNever(x.type);
    }), [',', printer_1.builders.hardline]);
    return printer_1.builders.concat([
        '{',
        printer_1.indent([printer_1.builders.hardline, renderedMembers]),
        printer_1.builders.hardline,
        '}',
    ]);
};
const renderType = (type) => {
    switch (type.type) {
        case 'LiteralType':
            return `'${type.data}'`;
        case 'TypeReference': {
            if (!type.data.arguments.length) {
                return type.data.name;
            }
            return printer_1.builders.concat([
                '<',
                printer_1.join(type.data.arguments.map(x => renderType(x)), printer_1.builders.line),
                '>',
            ]);
        }
        case 'UnionType':
            return printer_1.join(type.data.map(renderType), ' | ');
        case 'TupleType':
            return printer_1.builders.concat([
                '[',
                printer_1.builders.softline,
                printer_1.join(type.data.map(renderType), ', '),
                printer_1.builders.softline,
                ' ]',
            ]);
        case 'ObjectType':
            return renderObjectType(type.data);
    }
};
const renderBlockBody = (nodes, preferMultiLine, options) => {
    const renderSingleLineBlock = (node) => printer_1.builders.concat([
        '{',
        printer_1.indent([printer_1.builders.line, render(node, options)]),
        printer_1.builders.line,
        '}',
    ]);
    const renderMultiLineBlock = (nodes) => printer_1.builders.concat([
        '{',
        printer_1.indent(printer_1.prefixAll(nodes.map(x => render(x, options)), printer_1.builders.hardline)),
        printer_1.builders.hardline,
        '}',
    ]);
    if (!nodes.length) {
        return '{}';
    }
    if (nodes.length === 1 && !preferMultiLine) {
        if (nodes[0].type === 'IfStatement') {
            return renderMultiLineBlock(nodes);
        }
        return renderSingleLineBlock(nodes[0]);
    }
    return renderMultiLineBlock(nodes);
};
function toString(ast, options) {
    return printer_1.print(render(ast, options), printerOptions);
}
exports.default = toString;
