"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_lowerfirst_1 = __importDefault(require("lodash.lowerfirst"));
const utils_1 = require("../../utils");
const JSAST = __importStar(require("./js-ast"));
const format_1 = require("./format");
const utils_2 = require("./utils");
const createVariableOrProperty = (isStaticContext, isDynamic, name, value) => {
    if (isStaticContext) {
        if (isDynamic) {
            return {
                type: 'MethodDefinition',
                data: {
                    key: `get ${name}`,
                    value: {
                        type: 'FunctionExpression',
                        data: {
                            params: [],
                            body: [{ type: 'Return', data: value }],
                        },
                    },
                },
            };
        }
        return {
            type: 'Property',
            data: { key: { type: 'Identifier', data: [name] }, value: value },
        };
    }
    else {
        return {
            type: 'VariableDeclaration',
            data: {
                type: 'AssignmentExpression',
                data: { left: { type: 'Identifier', data: [name] }, right: value },
            },
        };
    }
};
const sharedPrefix = (rootNode, a, b, context) => {
    function inner(aPath, bPath) {
        const a = aPath.shift();
        const b = bPath.shift();
        if ((aPath.length > 0, a === b)) {
            return [aPath[0], ...inner(aPath, bPath)];
        }
        return [];
    }
    const aPath = context.helpers.ast.traversal.declarationPathTo(rootNode, a);
    const bPath = context.helpers.ast.traversal.declarationPathTo(rootNode, b);
    return inner(aPath, bPath);
};
function fontWeight(weight) {
    return { type: 'Literal', data: { type: 'Number', data: weight } };
}
function evaluateColor(node, context) {
    if (!context.helpers.evaluationContext) {
        return undefined;
    }
    const color = context.helpers.evaluationContext.evaluate(node.data.id);
    if (!color ||
        color.type.type !== 'constant' ||
        color.type.name !== 'Color' ||
        color.memory.type !== 'record' ||
        !color.memory.value.value ||
        color.memory.value.value.memory.type !== 'string') {
        return undefined;
    }
    return {
        type: 'Literal',
        data: {
            type: 'Color',
            data: color.memory.value.value.memory.value,
        },
    };
}
const hardcoded = {
    functionCallExpression: {
        'Color.saturate': evaluateColor,
        'Color.setHue': evaluateColor,
        'Color.setSaturation': evaluateColor,
        'Color.setLightness': evaluateColor,
        'Color.fromHSL': evaluateColor,
        'Boolean.or': (node, context) => {
            if (!node.data.arguments[0] ||
                node.data.arguments[0].type !== 'argument' ||
                !node.data.arguments[1] ||
                node.data.arguments[1].type !== 'argument') {
                throw new Error('The first 2 arguments of `Boolean.or` need to be a value');
            }
            return {
                type: 'BinaryExpression',
                data: {
                    left: expression(node.data.arguments[0].data.expression, context),
                    operator: JSAST.binaryOperator.Or,
                    right: expression(node.data.arguments[1].data.expression, context),
                },
            };
        },
        'Boolean.and': (node, context) => {
            if (!node.data.arguments[0] ||
                node.data.arguments[0].type !== 'argument' ||
                !node.data.arguments[1] ||
                node.data.arguments[1].type !== 'argument') {
                throw new Error('The first 2 arguments of `Boolean.and` need to be a value');
            }
            return {
                type: 'BinaryExpression',
                data: {
                    left: expression(node.data.arguments[0].data.expression, context),
                    operator: JSAST.binaryOperator.And,
                    right: expression(node.data.arguments[1].data.expression, context),
                },
            };
        },
        'String.concat': (node, context) => {
            if (!node.data.arguments[0] ||
                node.data.arguments[0].type !== 'argument' ||
                !node.data.arguments[1] ||
                node.data.arguments[1].type !== 'argument') {
                throw new Error('The first 2 arguments of `String.concat` need to be a value');
            }
            // TODO:
            return undefined;
        },
        'Number.range': (node, context) => {
            if (!node.data.arguments[0] ||
                node.data.arguments[0].type !== 'argument' ||
                !node.data.arguments[1] ||
                node.data.arguments[1].type !== 'argument' ||
                !node.data.arguments[2] ||
                node.data.arguments[2].type !== 'argument') {
                throw new Error('The first 3 arguments of `Number.range` need to be a value');
            }
            // TODO:
            return undefined;
        },
        'Array.at': (node, context) => {
            if (!node.data.arguments[0] ||
                node.data.arguments[0].type !== 'argument' ||
                !node.data.arguments[1] ||
                node.data.arguments[1].type !== 'argument') {
                throw new Error('The first 2 arguments of `Array.at` need to be a value');
            }
            // TODO:
            return undefined;
        },
        'Optional.value': (node, context) => {
            if (!node.data.arguments[0] ||
                node.data.arguments[0].type !== 'argument') {
                throw new Error('The first argument of `Optional.value` needs to be a value');
            }
            return expression(node.data.arguments[0].data.expression, context);
        },
        Shadow: () => {
            // polyfilled
            return undefined;
        },
        TextStyle: () => {
            // polyfilled
            return undefined;
        },
        'Optional.none': () => ({
            type: 'Literal',
            data: { type: 'Undefined', data: undefined },
        }),
        'FontWeight.ultraLight': () => fontWeight(100),
        'FontWeight.thin': () => fontWeight(200),
        'FontWeight.light': () => fontWeight(300),
        'FontWeight.regular': () => fontWeight(400),
        'FontWeight.medium': () => fontWeight(500),
        'FontWeight.semibold': () => fontWeight(600),
        'FontWeight.bold': () => fontWeight(700),
        'FontWeight.heavy': () => fontWeight(800),
        'FontWeight.black': () => fontWeight(900),
    },
    memberExpression: {
        'FontWeight.w100': () => fontWeight(100),
        'FontWeight.w200': () => fontWeight(200),
        'FontWeight.w300': () => fontWeight(300),
        'FontWeight.w400': () => fontWeight(400),
        'FontWeight.w500': () => fontWeight(500),
        'FontWeight.w600': () => fontWeight(600),
        'FontWeight.w700': () => fontWeight(700),
        'FontWeight.w800': () => fontWeight(800),
        'FontWeight.w900': () => fontWeight(900),
    },
};
function convert(node, filePath, helpers) {
    const imports = {};
    function importIdentifier(identifier, from) {
        if (!imports[from]) {
            imports[from] = new Set();
        }
        imports[from].add(identifier);
    }
    const context = {
        isStatic: false,
        isTopLevel: true,
        rootNode: node,
        filePath,
        helpers,
        importIdentifier,
        resolveStandardLibrary: helpers.createStandardLibraryResolver(hardcoded),
    };
    const program = helpers.ast.makeProgram(node);
    if (!program) {
        helpers.reporter.warn(`Unhandled syntaxNode type "${node.type}"`);
        return { type: 'Empty' };
    }
    const data = program.data.block
        .filter(x => x.type !== 'placeholder')
        .map(x => statement(x, context));
    const importNodes = Object.keys(imports).map(source => {
        return {
            type: 'ImportDeclaration',
            data: {
                source: utils_2.resolveImportPath(filePath, source),
                specifiers: Array.from(imports[source]).map(x => ({
                    type: 'ImportSpecifier',
                    data: {
                        imported: x,
                    },
                })),
            },
        };
    });
    return {
        type: 'Program',
        data: importNodes.concat(data),
    };
}
exports.default = convert;
const statement = (node, context) => {
    const potentialHandled = context.resolveStandardLibrary(node, context.helpers.evaluationContext, context);
    if (potentialHandled) {
        return potentialHandled;
    }
    switch (node.type) {
        case 'branch': {
            return {
                type: 'IfStatement',
                data: {
                    test: expression(node.data.condition, context),
                    consequent: node.data.block
                        .filter(x => x.type !== 'placeholder')
                        .map(x => statement(x, context)),
                    alternate: [],
                },
            };
        }
        case 'declaration':
            return declaration(node.data.content, context);
        case 'expression':
            return expression(node.data.expression, context);
        case 'loop': {
            return {
                type: 'WhileStatement',
                data: {
                    test: expression(node.data.expression, context),
                    body: node.data.block
                        .filter(x => x.type !== 'placeholder')
                        .map(x => statement(x, context)),
                },
            };
        }
        case 'return': {
            return { type: 'Return', data: expression(node.data.expression, context) };
        }
        case 'placeholder':
            return { type: 'Empty' };
        default: {
            utils_1.typeNever(node, context.helpers.reporter.warn);
            return { type: 'Empty' };
        }
    }
};
const declaration = (node, context) => {
    const potentialHandled = context.resolveStandardLibrary(node, context.helpers.evaluationContext, context);
    if (potentialHandled) {
        return potentialHandled;
    }
    switch (node.type) {
        case 'importDeclaration':
            return { type: 'Empty' };
        case 'function': {
            return {
                type: 'FunctionExpression',
                data: {
                    id: node.data.name.name,
                    params: node.data.parameters
                        .map(x => {
                        if (x.type !== 'parameter') {
                            return undefined;
                        }
                        const identifier = {
                            type: 'Identifier',
                            data: [x.data.localName.name],
                        };
                        if (!x.data.defaultValue || x.data.defaultValue.type === 'none') {
                            return identifier;
                        }
                        return {
                            type: 'AssignmentExpression',
                            data: {
                                left: identifier,
                                right: expression(x.data.defaultValue.data.expression, context),
                            },
                        };
                    })
                        .filter(utils_1.nonNullable),
                    body: node.data.block
                        .filter(x => x.type !== 'placeholder')
                        .map(x => statement(x, context)),
                },
            };
        }
        case 'namespace': {
            const newContext = Object.assign(Object.assign({}, context), { isTopLevel: false, isStatic: true });
            const variable = createVariableOrProperty(context.isStatic, false, node.data.name.name.toLowerCase(), {
                type: 'Literal',
                data: {
                    type: 'Object',
                    data: node.data.declarations
                        .filter(x => x.type !== 'placeholder')
                        .map(x => declaration(x, newContext)),
                },
            });
            if (context.isTopLevel &&
                variable.type === 'VariableDeclaration' &&
                variable.data.type === 'AssignmentExpression') {
                return {
                    type: 'ExportNamedDeclaration',
                    data: variable.data,
                };
            }
            return variable;
        }
        case 'variable': {
            const newContext = Object.assign(Object.assign({}, context), { isTopLevel: false });
            const initialValue = node.data.initializer
                ? expression(node.data.initializer, newContext)
                : { type: 'Identifier', data: ['undefined'] };
            const isDynamic = context.helpers.ast.traversal.reduce({
                type: 'declaration',
                data: {
                    id: '',
                    content: node,
                },
            }, (prev, child) => {
                if (child.type === 'expression' &&
                    child.data.expression.type === 'identifierExpression') {
                    const prefix = sharedPrefix(context.rootNode, node.data.id, child.data.expression.data.id, context);
                    if (prefix.length === 0) {
                        return prev;
                    }
                    return true;
                }
                return prev;
            }, false);
            const variable = createVariableOrProperty(context.isStatic, isDynamic, node.data.name.name.toLowerCase(), initialValue);
            if (context.isTopLevel &&
                variable.type === 'VariableDeclaration' &&
                variable.data.type === 'AssignmentExpression') {
                return {
                    type: 'ExportNamedDeclaration',
                    data: variable.data,
                };
            }
            return variable;
        }
        case 'record':
            return { type: 'Empty' };
        case 'enumeration':
            return {
                type: 'VariableDeclaration',
                data: {
                    type: 'AssignmentExpression',
                    data: {
                        left: { type: 'Identifier', data: [format_1.enumName(node.data.name.name)] },
                        right: {
                            type: 'Literal',
                            data: {
                                type: 'Object',
                                data: node.data.cases
                                    .map(x => {
                                    if (x.type === 'placeholder') {
                                        return undefined;
                                    }
                                    /* TODO: Handle enums with associated data */
                                    return {
                                        type: 'Property',
                                        data: {
                                            key: {
                                                type: 'Identifier',
                                                data: [format_1.enumName(x.data.name.name)],
                                            },
                                            value: {
                                                type: 'Literal',
                                                data: { type: 'String', data: x.data.name.name },
                                            },
                                        },
                                    };
                                })
                                    .filter(utils_1.nonNullable),
                            },
                        },
                    },
                },
            };
        case 'placeholder':
            return { type: 'Empty' };
        default: {
            utils_1.typeNever(node, context.helpers.reporter.warn);
            return { type: 'Empty' };
        }
    }
};
const expression = (node, context) => {
    var _a, _b, _c, _d;
    const potentialHandled = context.resolveStandardLibrary(node, context.helpers.evaluationContext, context);
    if (potentialHandled) {
        return potentialHandled;
    }
    switch (node.type) {
        case 'identifierExpression': {
            const isFromOtherFile = (_a = context.helpers.evaluationContext) === null || _a === void 0 ? void 0 : _a.isFromOtherFile(node.data.identifier.id, context.filePath);
            const standard = {
                type: 'Identifier',
                data: [lodash_lowerfirst_1.default(node.data.identifier.string)],
            };
            const patternId = (_b = context.helpers.evaluationContext) === null || _b === void 0 ? void 0 : _b.getPattern(node.data.identifier.id);
            if (!patternId) {
                if (isFromOtherFile) {
                    context.importIdentifier(standard.data[0], isFromOtherFile);
                }
                return standard;
            }
            const pattern = context.helpers.ast.traversal.declarationPathTo(context.rootNode, patternId);
            if (!pattern.length) {
                if (isFromOtherFile) {
                    context.importIdentifier(standard.data[0], isFromOtherFile);
                }
                return standard;
            }
            if (isFromOtherFile) {
                context.importIdentifier(lodash_lowerfirst_1.default(pattern[0]), isFromOtherFile);
            }
            return {
                type: 'Identifier',
                data: pattern.map(lodash_lowerfirst_1.default),
            };
        }
        case 'literalExpression':
            return literal(node.data.literal, context);
        case 'memberExpression':
            return {
                type: 'MemberExpression',
                data: {
                    memberName: lodash_lowerfirst_1.default(node.data.memberName.string),
                    expression: expression(node.data.expression, context),
                },
            };
        case 'functionCallExpression': {
            const validArguments = node.data.arguments.filter(x => x.type !== 'placeholder');
            const standard = {
                type: 'CallExpression',
                data: {
                    callee: expression(node.data.expression, context),
                    arguments: node.data.arguments
                        .map(x => x.type === 'placeholder'
                        ? undefined
                        : expression(x.data.expression, context))
                        .filter(utils_1.nonNullable),
                },
            };
            const lastIdentifier = node.data.expression.type === 'identifierExpression'
                ? node.data.expression.data.identifier
                : node.data.expression.type === 'memberExpression'
                    ? node.data.expression.data.memberName
                    : undefined;
            if (!lastIdentifier) {
                return standard;
            }
            /* Does the identifier point to a defined pattern? */
            const identifierPatternId = (_c = context.helpers.evaluationContext) === null || _c === void 0 ? void 0 : _c.getPattern(lastIdentifier.id);
            /* Does the expression point to a defined pattern? (used for member expressions) */
            const expressionPatternId = (_d = context.helpers.evaluationContext) === null || _d === void 0 ? void 0 : _d.getPattern(node.data.expression.data.id);
            const patternId = identifierPatternId || expressionPatternId;
            if (!patternId || !context.helpers.evaluationContext) {
                return standard;
            }
            const parent = context.helpers.ast.traversal.findParentNode(context.helpers.evaluationContext.rootNode, patternId);
            if (!parent) {
                return standard;
            }
            if ('type' in parent &&
                parent.type === 'declaration' &&
                parent.data.content.type === 'record') {
                const recordDefinition = parent.data.content.data.declarations
                    .map(x => x.type === 'variable' && x.data.initializer
                    ? { name: x.data.name.name, defaultValue: x.data.initializer }
                    : undefined)
                    .filter(utils_1.nonNullable);
                return {
                    type: 'Literal',
                    data: {
                        type: 'Object',
                        data: recordDefinition.map(x => {
                            const found = validArguments.find(arg => arg.type !== 'placeholder' &&
                                arg.data.label &&
                                arg.data.label === x.name);
                            if (found && found.type === 'argument') {
                                return {
                                    type: 'Property',
                                    data: {
                                        key: { type: 'Identifier', data: [x.name] },
                                        value: expression(found.data.expression, context),
                                    },
                                };
                            }
                            return {
                                type: 'Property',
                                data: {
                                    key: { type: 'Identifier', data: [x.name] },
                                    value: expression(x.defaultValue, context),
                                },
                            };
                        }),
                    },
                };
            }
            if ('type' in parent &&
                parent.type === 'declaration' &&
                parent.data.content.type === 'enumeration') {
                const enumeration = context.helpers.ast.traversal.findParentNode(context.helpers.evaluationContext.rootNode, parent.data.id);
                if (enumeration &&
                    'type' in enumeration &&
                    enumeration.type === 'enumerationCase') {
                    return {
                        type: 'Literal',
                        data: {
                            type: 'String',
                            data: enumeration.data.name.name,
                        },
                    };
                }
            }
            return standard;
        }
        case 'assignmentExpression': {
            return {
                type: 'AssignmentExpression',
                data: {
                    left: expression(node.data.left, context),
                    right: expression(node.data.right, context),
                },
            };
        }
        case 'placeholder': {
            context.helpers.reporter.warn('Placeholder expression remaining');
            return { type: 'Empty' };
        }
        default: {
            utils_1.typeNever(node, context.helpers.reporter.warn);
            return { type: 'Empty' };
        }
    }
};
const literal = (node, context) => {
    const potentialHandled = context.resolveStandardLibrary(node, context.helpers.evaluationContext, context);
    if (potentialHandled) {
        return potentialHandled;
    }
    switch (node.type) {
        case 'none': {
            return {
                type: 'Literal',
                data: { type: 'Undefined', data: undefined },
            };
        }
        case 'boolean': {
            return {
                type: 'Literal',
                data: { type: 'Boolean', data: node.data.value },
            };
        }
        case 'number': {
            return {
                type: 'Literal',
                data: { type: 'Number', data: node.data.value },
            };
        }
        case 'string': {
            return {
                type: 'Literal',
                data: { type: 'String', data: node.data.value },
            };
        }
        case 'color': {
            return {
                type: 'Literal',
                data: { type: 'Color', data: node.data.value },
            };
        }
        case 'array': {
            return {
                type: 'Literal',
                data: {
                    type: 'Array',
                    data: node.data.value
                        .filter(x => x.type !== 'placeholder')
                        .map(x => expression(x, context)),
                },
            };
        }
        default: {
            utils_1.typeNever(node, context.helpers.reporter.warn);
            return { type: 'Empty' };
        }
    }
};
