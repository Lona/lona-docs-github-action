import * as LogicUnify from './logic-unify';
import * as LogicAST from './logic-ast';
import * as LogicScope from './logic-scope';
import { Reporter } from './reporter';
import { ShallowMap } from '../utils';
export declare type Memory = {
    type: 'unit';
} | {
    type: 'bool';
    value: boolean;
} | {
    type: 'number';
    value: number;
} | {
    type: 'string';
    value: string;
} | {
    type: 'array';
    value: Value[];
} | {
    type: 'enum';
    value: string;
    data: Value[];
} | {
    type: 'record';
    value: {
        [key: string]: Value;
    };
} | {
    type: 'function';
    value: {
        type: 'path';
        value: string[];
    } | {
        type: 'recordInit';
        value: {
            [key: string]: [LogicUnify.Unification, Value | void];
        };
    } | {
        type: 'enumInit';
        value: string;
    };
};
export declare type Value = {
    type: LogicUnify.Unification;
    memory: Memory;
};
declare type Thunk = {
    label: string;
    dependencies: string[];
    f: (args: Value[]) => Value;
};
/**
 * The evaluation context of the Lona Workspace.
 *
 * It contains some mapping between the identifiers and what they reference,
 * eg. `Optional.none` -> the function declaration in Prelude.logic
 * which is used to evaluate `Optional.none` to
 * `{ type: unit, memory: { type: 'unit' } }` for example. It takes care of
 * the scope of the identifier to determine the reference.
 *
 * Additionally, it keeps track of where declaration are from.
 */
export declare class EvaluationContext {
    private values;
    private thunks;
    private scopeContext;
    private reporter;
    /** The root Logic node used to build the evaluation context  */
    rootNode: LogicAST.AST.SyntaxNode;
    constructor(scopeContext: LogicScope.ScopeContext, rootNode: LogicAST.AST.SyntaxNode, reporter: Reporter);
    add(uuid: string, thunk: Thunk): void;
    addValue(uuid: string, value: Value): void;
    /** Whether the id references something from the Lona's standard library */
    isFromStandardLibrary(uuid: string): boolean;
    /** Whether the id references something from another file,
     * and returns that file if true */
    isFromOtherFile(uuid: string, currentFile: string): string | undefined;
    getPattern(uuid: string): string | undefined;
    private getOriginalFile;
    /** Evaluate the id to a value, resolving any dependency along the way */
    evaluate(uuid: string): Value | undefined;
}
export declare const evaluate: (node: LogicAST.AST.SyntaxNode, rootNode: LogicAST.AST.SyntaxNode, scopeContext: LogicScope.ScopeContext, unificationContext: LogicUnify.UnificationContext, substitution: ShallowMap<LogicUnify.Unification, LogicUnify.Unification>, reporter: Reporter, context_?: EvaluationContext) => EvaluationContext | undefined;
export {};
