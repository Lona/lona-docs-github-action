"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_intersection_1 = __importDefault(require("lodash.intersection"));
const LogicTraversal = __importStar(require("./logic-traversal"));
const utils_1 = require("../utils");
/* Builtins */
exports.unit = {
    type: 'constant',
    name: 'Void',
    parameters: [],
};
exports.bool = {
    type: 'constant',
    name: 'Boolean',
    parameters: [],
};
exports.number = {
    type: 'constant',
    name: 'Number',
    parameters: [],
};
exports.string = {
    type: 'constant',
    name: 'String',
    parameters: [],
};
exports.color = {
    type: 'constant',
    name: 'Color',
    parameters: [],
};
exports.shadow = {
    type: 'constant',
    name: 'Shadow',
    parameters: [],
};
exports.textStyle = {
    type: 'constant',
    name: 'TextStyle',
    parameters: [],
};
exports.optional = (type) => ({
    type: 'constant',
    name: 'Optional',
    parameters: [type],
});
exports.array = (typeUnification) => ({
    type: 'constant',
    name: 'Array',
    parameters: [typeUnification],
});
class LogicNameGenerator {
    constructor(prefix = '') {
        this.currentIndex = 0;
        this.prefix = prefix;
    }
    next() {
        this.currentIndex += 1;
        let name = this.currentIndex.toString(36);
        return `${this.prefix}${name}`;
    }
}
function unificationType(genericsInScope, getName, typeAnnotation) {
    if (typeAnnotation.type === 'typeIdentifier') {
        const { string, isPlaceholder } = typeAnnotation.data.identifier;
        if (isPlaceholder) {
            return {
                type: 'variable',
                value: getName(),
            };
        }
        const generic = genericsInScope.find(g => g[0] === string);
        if (generic) {
            return {
                type: 'generic',
                name: generic[1],
            };
        }
        const parameters = typeAnnotation.data.genericArguments.map(arg => unificationType(genericsInScope, getName, arg));
        return {
            type: 'constant',
            name: string,
            parameters,
        };
    }
    if (typeAnnotation.type === 'placeholder') {
        return {
            type: 'variable',
            value: getName(),
        };
    }
    return {
        type: 'variable',
        value: 'Function type error',
    };
}
function substitute(substitution, type) {
    let resolvedType = substitution.get(type);
    if (!resolvedType) {
        resolvedType = type;
    }
    if (resolvedType.type === 'variable' || resolvedType.type === 'generic') {
        return resolvedType;
    }
    if (resolvedType.type === 'constant') {
        return {
            type: 'constant',
            name: resolvedType.name,
            parameters: resolvedType.parameters.map(x => substitute(substitution, x)),
        };
    }
    if (resolvedType.type === 'function') {
        return {
            type: 'function',
            returnType: substitute(substitution, resolvedType.returnType),
            arguments: resolvedType.arguments.map(arg => ({
                label: arg.label,
                type: substitute(substitution, arg.type),
            })),
        };
    }
    utils_1.assertNever(resolvedType);
}
exports.substitute = substitute;
function genericNames(type) {
    if (type.type === 'variable') {
        return [];
    }
    if (type.type === 'constant') {
        return type.parameters
            .map(genericNames)
            .reduce((prev, x) => prev.concat(x), []);
    }
    if (type.type === 'generic') {
        return [type.name];
    }
    if (type.type === 'function') {
        return type.arguments
            .map(x => x.type)
            .concat(type.returnType)
            .map(genericNames)
            .reduce((prev, x) => prev.concat(x), []);
    }
    utils_1.assertNever(type);
}
function replaceGenericsWithVars(getName, type) {
    let substitution = new utils_1.ShallowMap();
    genericNames(type).forEach(name => substitution.set({ type: 'generic', name }, { type: 'variable', value: getName() }));
    return substitute(substitution, type);
}
function specificIdentifierType(scopeContext, unificationContext, id) {
    const patternId = scopeContext.identifierToPattern[id];
    if (!patternId) {
        return {
            type: 'variable',
            value: unificationContext.typeNameGenerator.next(),
        };
    }
    const scopedType = unificationContext.patternTypes[patternId.pattern];
    if (!scopedType) {
        return {
            type: 'variable',
            value: unificationContext.typeNameGenerator.next(),
        };
    }
    return replaceGenericsWithVars(() => unificationContext.typeNameGenerator.next(), scopedType);
}
const makeEmptyContext = () => ({
    constraints: [],
    nodes: {},
    patternTypes: {},
    typeNameGenerator: new LogicNameGenerator('?'),
});
exports.makeUnificationContext = (rootNode, scopeContext, reporter, initialContext = makeEmptyContext()) => {
    let build = (result, node, config) => {
        config.needsRevisitAfterTraversingChildren = true;
        if (node.type === 'branch' && config._isRevisit) {
            result.nodes[node.data.condition.data.id] = exports.bool;
        }
        if (node.type === 'record' && !config._isRevisit) {
            const genericNames = node.data.genericParameters
                .map(param => param.type === 'parameter' ? param.data.name.name : undefined)
                .filter(utils_1.nonNullable);
            const genericsInScope = genericNames.map(x => [
                x,
                result.typeNameGenerator.next(),
            ]);
            const universalTypes = genericNames.map((x, i) => ({
                type: 'generic',
                name: genericsInScope[i][1],
            }));
            let parameterTypes = [];
            node.data.declarations.forEach(declaration => {
                if (declaration.type !== 'variable' || !declaration.data.annotation) {
                    return;
                }
                const { annotation, name } = declaration.data;
                const annotationType = unificationType([], () => result.typeNameGenerator.next(), annotation);
                parameterTypes.unshift({
                    label: name.name,
                    type: annotationType,
                });
                result.nodes[name.id] = annotationType;
                result.patternTypes[name.id] = annotationType;
            });
            const returnType = {
                type: 'constant',
                name: node.data.name.name,
                parameters: universalTypes,
            };
            const functionType = {
                type: 'function',
                returnType,
                arguments: parameterTypes,
            };
            result.nodes[node.data.name.id] = functionType;
            result.patternTypes[node.data.name.id] = functionType;
        }
        if (node.type === 'enumeration' && !config._isRevisit) {
            const genericNames = node.data.genericParameters
                .map(param => param.type === 'parameter' ? param.data.name.name : undefined)
                .filter(utils_1.nonNullable);
            const genericsInScope = genericNames.map(x => [
                x,
                result.typeNameGenerator.next(),
            ]);
            const universalTypes = genericNames.map((x, i) => ({
                type: 'generic',
                name: genericsInScope[i][1],
            }));
            const returnType = {
                type: 'constant',
                name: node.data.name.name,
                parameters: universalTypes,
            };
            node.data.cases.forEach(enumCase => {
                if (enumCase.type === 'placeholder') {
                    return;
                }
                const parameterTypes = enumCase.data.associatedValueTypes
                    .map(annotation => {
                    if (annotation.type === 'placeholder') {
                        return;
                    }
                    return {
                        label: undefined,
                        type: unificationType(genericsInScope, () => result.typeNameGenerator.next(), annotation),
                    };
                })
                    .filter(utils_1.nonNullable);
                const functionType = {
                    type: 'function',
                    returnType,
                    arguments: parameterTypes,
                };
                result.nodes[enumCase.data.name.id] = functionType;
                result.patternTypes[enumCase.data.name.id] = functionType;
            });
            /* Not used for unification, but used for convenience in evaluation */
            result.nodes[node.data.name.id] = returnType;
            result.patternTypes[node.data.name.id] = returnType;
        }
        if (node.type === 'function' && !config._isRevisit) {
            const genericNames = node.data.genericParameters
                .map(param => param.type === 'parameter' ? param.data.name.name : undefined)
                .filter(utils_1.nonNullable);
            const genericsInScope = genericNames.map(x => [
                x,
                result.typeNameGenerator.next(),
            ]);
            let parameterTypes = [];
            node.data.parameters.forEach(param => {
                if (param.type === 'placeholder') {
                    return;
                }
                const { name, id } = param.data.localName;
                let annotationType = unificationType([], () => result.typeNameGenerator.next(), param.data.annotation);
                parameterTypes.unshift({ label: name, type: annotationType });
                result.nodes[id] = annotationType;
                result.patternTypes[id] = annotationType;
            });
            let returnType = unificationType(genericsInScope, () => result.typeNameGenerator.next(), node.data.returnType);
            let functionType = {
                type: 'function',
                returnType,
                arguments: parameterTypes,
            };
            result.nodes[node.data.name.id] = functionType;
            result.patternTypes[node.data.name.id] = functionType;
        }
        if (node.type === 'variable' && config._isRevisit) {
            if (!node.data.initializer ||
                !node.data.annotation ||
                node.data.annotation.type === 'placeholder') {
                config.ignoreChildren = true;
            }
            else {
                const annotationType = unificationType([], () => result.typeNameGenerator.next(), node.data.annotation);
                const initializerId = node.data.initializer.data.id;
                const initializerType = result.nodes[initializerId];
                if (initializerType) {
                    result.constraints.push({
                        head: annotationType,
                        tail: initializerType,
                    });
                }
                else {
                    reporter.error(`WARNING: No initializer type for ${node.data.name.name} (${initializerId})`);
                }
                result.patternTypes[node.data.name.id] = annotationType;
            }
        }
        if (node.type === 'placeholder' && config._isRevisit) {
            result.nodes[node.data.id] = {
                type: 'variable',
                value: result.typeNameGenerator.next(),
            };
        }
        if (node.type === 'identifierExpression' && config._isRevisit) {
            let type = specificIdentifierType(scopeContext, result, node.data.identifier.id);
            result.nodes[node.data.id] = type;
            result.nodes[node.data.identifier.id] = type;
        }
        if (node.type === 'functionCallExpression' && config._isRevisit) {
            const calleeType = result.nodes[node.data.expression.data.id];
            /* Unify against these to enforce a function type */
            const placeholderReturnType = {
                type: 'variable',
                value: result.typeNameGenerator.next(),
            };
            const placeholderArgTypes = node.data.arguments
                .map(arg => {
                if (arg.type === 'placeholder') {
                    return;
                }
                return {
                    label: arg.data.label,
                    type: {
                        type: 'variable',
                        value: result.typeNameGenerator.next(),
                    },
                };
            })
                .filter(utils_1.nonNullable);
            const placeholderFunctionType = {
                type: 'function',
                returnType: placeholderReturnType,
                arguments: placeholderArgTypes,
            };
            result.constraints.push({
                head: calleeType,
                tail: placeholderFunctionType,
            });
            result.nodes[node.data.id] = placeholderReturnType;
            let argumentValues = node.data.arguments
                .map(arg => arg.type === 'placeholder' ? undefined : arg.data.expression)
                .filter(utils_1.nonNullable);
            const constraints = placeholderArgTypes.map((argType, i) => ({
                head: argType.type,
                tail: result.nodes[argumentValues[i].data.id],
                origin: node,
            }));
            result.constraints = result.constraints.concat(constraints);
        }
        if (node.type === 'memberExpression') {
            if (!config._isRevisit) {
                config.ignoreChildren = true;
            }
            else {
                let type = specificIdentifierType(scopeContext, result, node.data.id);
                result.nodes[node.data.id] = type;
            }
        }
        if (node.type === 'literalExpression' && config._isRevisit) {
            result.nodes[node.data.id] = result.nodes[node.data.literal.data.id];
        }
        /* TODO: Binary expression */
        if (node.type === 'boolean' && config._isRevisit) {
            result.nodes[node.data.id] = exports.bool;
        }
        if (node.type === 'number' && config._isRevisit) {
            result.nodes[node.data.id] = exports.number;
        }
        if (node.type === 'string' && config._isRevisit) {
            result.nodes[node.data.id] = exports.string;
        }
        if (node.type === 'color' && config._isRevisit) {
            result.nodes[node.data.id] = exports.color;
        }
        if (node.type === 'array' && config._isRevisit) {
            const elementType = {
                type: 'variable',
                value: result.typeNameGenerator.next(),
            };
            result.nodes[node.data.id] = elementType;
            const constraints = node.data.value.map(expression => ({
                head: elementType,
                tail: result.nodes[expression.data.id] || {
                    type: 'variable',
                    value: result.typeNameGenerator.next(),
                },
                origin: node,
            }));
            result.constraints = result.constraints.concat(constraints);
        }
        return result;
    };
    return LogicTraversal.reduce(rootNode, build, initialContext);
};
exports.unify = (constraints, reporter, substitution = new utils_1.ShallowMap()) => {
    while (constraints.length > 0) {
        const constraint = constraints.shift();
        if (!constraint) {
            // that's not possible, so it's just for TS
            continue;
        }
        let { head, tail } = constraint;
        if (head == tail) {
            continue;
        }
        if (head.type === 'function' && tail.type === 'function') {
            const headArguments = head.arguments;
            const tailArguments = tail.arguments;
            const headContainsLabels = headArguments.some(x => x.label);
            const tailContainsLabels = tailArguments.some(x => x.label);
            if ((headContainsLabels && !tailContainsLabels && tailArguments.length) ||
                (tailContainsLabels && !headContainsLabels && headArguments.length)) {
                reporter.error(headArguments, tailArguments);
                throw new Error(`[UnificationError] [GenericArgumentsLabelMismatch]`);
            }
            if (!headContainsLabels && !tailContainsLabels) {
                if (headArguments.length !== tailArguments.length) {
                    throw new Error(`[UnificationError] [GenericArgumentsCountMismatch] ${head} ${tail}`);
                }
                headArguments.forEach((a, i) => {
                    constraints.push({
                        head: a.type,
                        tail: tailArguments[i].type,
                    });
                });
            }
            else {
                const headLabels = headArguments
                    .map(arg => arg.label)
                    .filter(utils_1.nonNullable);
                const tailLabels = tailArguments
                    .map(arg => arg.label)
                    .filter(utils_1.nonNullable);
                let common = lodash_intersection_1.default(headLabels, tailLabels);
                common.forEach(label => {
                    const headArgumentType = headArguments.find(arg => arg.label === label);
                    const tailArgumentType = tailArguments.find(arg => arg.label === label);
                    if (!headArgumentType || !tailArgumentType) {
                        // not possible but here for TS
                        return;
                    }
                    constraints.push({
                        head: headArgumentType.type,
                        tail: tailArgumentType.type,
                    });
                });
            }
            constraints.push({
                head: head.returnType,
                tail: tail.returnType,
            });
        }
        else if (head.type === 'constant' && tail.type === 'constant') {
            if (head.name !== tail.name) {
                reporter.error(head, tail);
                throw new Error(`[UnificationError] [NameMismatch] ${head.name} ${tail.name}`);
            }
            const headParameters = head.parameters;
            const tailParameters = tail.parameters;
            if (headParameters.length !== tailParameters.length) {
                throw new Error(`[UnificationError] [GenericArgumentsCountMismatch] ${head} ${tail}`);
            }
            headParameters.forEach((a, i) => {
                constraints.push({
                    head: a,
                    tail: tailParameters[i],
                });
            });
        }
        else if (head.type === 'generic' || tail.type === 'generic') {
            reporter.error('tried to unify generics (problem?)', head, tail);
        }
        else if (head.type === 'variable') {
            substitution.set(head, tail);
        }
        else if (tail.type === 'variable') {
            substitution.set(tail, head);
        }
        else if ((head.type === 'constant' && tail.type === 'function') ||
            (head.type === 'function' && tail.type === 'constant')) {
            throw new Error(`[UnificationError] [KindMismatch] ${head} ${tail}`);
        }
        constraints = constraints.map(c => {
            const head = substitution.get(c.head);
            const tail = substitution.get(c.tail);
            if (head && tail) {
                return { head, tail, origin: c };
            }
            if (head) {
                return {
                    head,
                    tail: c.tail,
                    origin: c,
                };
            }
            if (tail) {
                return {
                    head: c.head,
                    tail,
                    origin: c,
                };
            }
            return c;
        });
    }
    return substitution;
};
