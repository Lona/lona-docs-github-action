"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const serialization_1 = require("@lona/serialization");
exports.AST = serialization_1.LogicAST;
const utils_1 = require("../utils");
/**
 * Takes an array of programs and returns a program containing
 * the statements of all programs
 */
function joinPrograms(programs) {
    return {
        type: 'program',
        data: {
            id: utils_1.uuid(),
            block: programs.reduce((prev, x) => (x ? prev.concat(x.data.block) : prev), []),
        },
    };
}
exports.joinPrograms = joinPrograms;
/** tries to make a program out of any Logic node */
function makeProgram(node) {
    if (node.type === 'program') {
        return node;
    }
    if (serialization_1.LogicAST.isStatement(node)) {
        return { type: 'program', data: { id: utils_1.uuid(), block: [node] } };
    }
    if (serialization_1.LogicAST.isDeclaration(node)) {
        return makeProgram({
            type: 'declaration',
            data: { id: utils_1.uuid(), content: node },
        });
    }
    if (node.type === 'topLevelDeclarations') {
        return {
            type: 'program',
            data: {
                id: utils_1.uuid(),
                block: node.data.declarations.map(x => ({
                    type: 'declaration',
                    data: { id: utils_1.uuid(), content: x },
                })),
            },
        };
    }
    return undefined;
}
exports.makeProgram = makeProgram;
function getPattern(node) {
    if (node.type === 'variable' ||
        node.type === 'enumeration' ||
        node.type === 'namespace' ||
        node.type === 'record' ||
        node.type === 'importDeclaration' ||
        node.type === 'enumerationCase' ||
        node.type === 'function') {
        return node.data.name;
    }
    if (node.type === 'parameter') {
        if ('localName' in node.data) {
            return node.data.localName;
        }
        return node.data.name;
    }
}
exports.getPattern = getPattern;
function getIdentifier(node) {
    if (node.type === 'identifierExpression' || node.type === 'typeIdentifier') {
        return node.data.identifier;
    }
    if (node.type === 'memberExpression') {
        return node.data.memberName;
    }
}
exports.getIdentifier = getIdentifier;
function flattenedMemberExpression(memberExpression) {
    if (memberExpression.type === 'identifierExpression') {
        return [memberExpression.data.identifier];
    }
    if (memberExpression.type !== 'memberExpression') {
        return undefined;
    }
    if (memberExpression.data.expression.type === 'identifierExpression') {
        return [
            memberExpression.data.expression.data.identifier,
            memberExpression.data.memberName,
        ];
    }
    const flattenedChildren = flattenedMemberExpression(memberExpression.data.expression);
    if (!flattenedChildren) {
        return undefined;
    }
    return flattenedChildren.concat(memberExpression.data.memberName);
}
exports.flattenedMemberExpression = flattenedMemberExpression;
function getNode(rootNode, id) {
    if (rootNode.data.id === id) {
        return rootNode;
    }
    if ('name' in rootNode.data && rootNode.data.name.id === id) {
        return rootNode;
    }
    const children = serialization_1.LogicAST.subNodes(rootNode);
    for (let child of children) {
        const node = getNode(child, id);
        if (node) {
            return node;
        }
    }
    return undefined;
}
exports.getNode = getNode;
function pathTo(rootNode, id) {
    if (id === ('id' in rootNode ? rootNode.id : rootNode.data.id)) {
        return [rootNode];
    }
    if (!('type' in rootNode)) {
        return undefined;
    }
    const pattern = getPattern(rootNode);
    if (pattern && pattern.id === id) {
        return [pattern];
    }
    const identifier = getIdentifier(rootNode);
    if (identifier && identifier.id === id) {
        return [identifier];
    }
    return serialization_1.LogicAST.subNodes(rootNode).reduce((prev, item) => {
        if (prev) {
            return prev;
        }
        const subPath = pathTo(item, id);
        if (subPath) {
            return [rootNode, ...subPath];
        }
        return undefined;
    }, undefined);
}
function findNode(rootNode, id) {
    const path = pathTo(rootNode, id);
    if (!path) {
        return undefined;
    }
    return path[path.length - 1];
}
exports.findNode = findNode;
function findParentNode(node, id) {
    const path = pathTo(node, id);
    if (!path || path.length <= 1) {
        return undefined;
    }
    const parent = path[path.length - 2];
    if (!('type' in parent)) {
        return undefined;
    }
    return parent;
}
exports.findParentNode = findParentNode;
function declarationPathTo(node, id) {
    const path = pathTo(node, id);
    if (!path) {
        return [];
    }
    return path.filter(serialization_1.LogicAST.isDeclaration).map(x => {
        switch (x.type) {
            case 'variable':
            case 'function':
            case 'enumeration':
            case 'namespace':
            case 'record':
            case 'importDeclaration': {
                return x.data.name.name;
            }
            case 'placeholder': {
                return '';
            }
        }
    });
}
exports.declarationPathTo = declarationPathTo;
