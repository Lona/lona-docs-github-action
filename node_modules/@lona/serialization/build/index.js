"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
const uuid_1 = require("uuid");
const mdx = __importStar(require("./mdx"));
const lona_format_1 = require("./lona-format");
exports.SERIALIZATION_FORMAT = lona_format_1.SERIALIZATION_FORMAT;
exports.detectFormat = lona_format_1.detectFormat;
const lona_logic_1 = require("./lona-logic");
exports.convertLogic = lona_logic_1.convertLogic;
exports.decodeLogic = lona_logic_1.decodeLogic;
exports.encodeLogic = lona_logic_1.encodeLogic;
const lona_types_1 = require("./lona-types");
exports.convertTypes = lona_types_1.convertTypes;
exports.decodeTypes = lona_types_1.decodeTypes;
exports.encodeTypes = lona_types_1.encodeTypes;
const MDXAST = __importStar(require("./types/lona-ast"));
exports.MDXAST = MDXAST;
const LogicAST = __importStar(require("./types/logic-ast"));
exports.LogicAST = LogicAST;
const TypesAST = __importStar(require("./types/types-ast"));
exports.TypesAST = TypesAST;
const utils_1 = require("./utils");
// Document
function decodeDocument(contents, format, filePath) {
    const sourceFormat = lona_format_1.normalizeFormat(contents, format);
    try {
        switch (sourceFormat) {
            case lona_format_1.SERIALIZATION_FORMAT.JSON:
                return JSON.parse(contents);
            case lona_format_1.SERIALIZATION_FORMAT.SOURCE:
                return mdx.parse(contents, filePath);
            default:
                throw new Error(`Unknown decoding format ${sourceFormat}`);
        }
    }
    catch (e) {
        console.error(e);
        throw new Error(`Failed to decode document as ${sourceFormat}.\n\n${e}`);
    }
}
exports.decodeDocument = decodeDocument;
function encodeDocument(ast, format, options = {}) {
    try {
        switch (format) {
            case lona_format_1.SERIALIZATION_FORMAT.JSON:
                return json_stable_stringify_1.default(ast, { space: '  ' });
            case lona_format_1.SERIALIZATION_FORMAT.SOURCE:
                return mdx.print(ast, options);
            default:
                throw new Error(`Unknown encoding format ${format}`);
        }
    }
    catch (e) {
        console.error(e);
        throw new Error(`Failed to encode document as ${format}.\n\n${e}`);
    }
}
exports.encodeDocument = encodeDocument;
function convertDocument(contents, targetFormat, options = {}) {
    const sourceFormat = lona_format_1.normalizeFormat(contents, options.sourceFormat);
    if (sourceFormat === targetFormat && !options.embeddedFormat)
        return contents;
    const ast = decodeDocument(contents, sourceFormat, options.filePath);
    return encodeDocument(ast, targetFormat, options);
}
exports.convertDocument = convertDocument;
function extractProgramFromAST(ast) {
    const { children } = ast;
    const declarations = children
        .filter(MDXAST.isLonaTokens)
        // Get Logic syntax node
        .map(child => child.data.parsed)
        // Get declarations
        .map(node => node.data.declarations);
    const flattened = declarations.reduce((prev, x) => prev.concat(x), []);
    const topLevelDeclarations = {
        data: {
            declarations: flattened,
            id: uuid_1.v4({ rng: utils_1.rng }).toUpperCase(),
        },
        type: 'topLevelDeclarations',
    };
    return topLevelDeclarations;
}
exports.extractProgramFromAST = extractProgramFromAST;
function extractProgram(contents, options = {}) {
    const sourceFormat = lona_format_1.normalizeFormat(contents, options.sourceFormat);
    const ast = decodeDocument(contents, sourceFormat);
    const program = extractProgramFromAST(ast);
    return json_stable_stringify_1.default(program, { space: '  ' });
}
exports.extractProgram = extractProgram;
const printMdxNode = mdx.printNode;
exports.printMdxNode = printMdxNode;
