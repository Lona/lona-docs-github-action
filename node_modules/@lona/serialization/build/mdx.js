"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mdx_1 = __importDefault(require("@mdx-js/mdx"));
const lona_logic_1 = require("./lona-logic");
const mdast_flatten_image_paragraphs_1 = __importDefault(require("mdast-flatten-image-paragraphs"));
const flattenParagraphs_1 = __importDefault(require("./mdast-transforms/flattenParagraphs"));
const moveToRoot_1 = __importDefault(require("./mdast-transforms/moveToRoot"));
const toMarkdown_1 = __importDefault(require("./mdast-transforms/toMarkdown"));
const parsePage_1 = __importDefault(require("./mdast-transforms/parsePage"));
const parseTokens_1 = __importDefault(require("./mdast-transforms/parseTokens"));
const lona_format_1 = require("./lona-format");
const flattenImageParagraphs = mdast_flatten_image_paragraphs_1.default();
const getOutputs = (src) => {
    let mdast;
    let hast = {};
    let jsx = mdx_1.default.sync(src, {
        skipExport: true,
        remarkPlugins: [
            () => ast => {
                mdast = ast;
                return ast;
            },
        ],
        rehypePlugins: [
            () => ast => {
                hast = ast;
                return ast;
            },
        ],
    });
    return { jsx, mdast, hast };
};
// Map mdast tree
function map(node, f) {
    if (node['children'] && Array.isArray(node['children'])) {
        const mappedChildren = node['children'].map(child => map(child, f));
        return f(Object.assign(Object.assign({}, node), { children: mappedChildren }));
    }
    return f(node);
}
function removeExtras(ast) {
    return map(ast, node => {
        delete node.position;
        return node;
    });
}
function parse(src, filePath) {
    const mdast = getOutputs(src).mdast;
    const transforms = [
        flattenImageParagraphs,
        flattenParagraphs_1.default('blockquote'),
        moveToRoot_1.default('image'),
        moveToRoot_1.default('blockquote'),
        removeExtras,
        parsePage_1.default(),
        parseTokens_1.default(src, filePath),
        moveToRoot_1.default('page'),
    ];
    const transformed = transforms.reduce((result, f) => f(result), mdast);
    const normalizedFormat = map(transformed, node => {
        const { type } = node, rest = __rest(node, ["type"]);
        return { type, data: rest };
    });
    return normalizedFormat.data;
}
exports.parse = parse;
// Convert our internal md format to mdast
function toMdast(node) {
    const { type, data } = node;
    if (node.type === 'page') {
        return {
            type: 'link',
            url: node.data.url,
            children: [
                {
                    type: 'text',
                    value: node.data.value,
                },
            ],
            page: true,
        };
    }
    if ('children' in data && Array.isArray(data.children)) {
        // @ts-ignore
        return Object.assign(Object.assign({ type }, data), { children: data.children.map(toMdast) });
    }
    // @ts-ignore
    return Object.assign({ type }, data);
}
// Print a block in our internal format to a markdown string
function printNode(mdxBlockNode) {
    return toMarkdown_1.default(toMdast(mdxBlockNode));
}
exports.printNode = printNode;
function print(normalizedFormat, options = {}) {
    const ast = { type: 'root', children: normalizedFormat.children.map(toMdast) };
    const encodedTokensAst = map(ast, node => {
        if (node.type === 'code' && node.lang === 'tokens') {
            const embeddedFormat = options.embeddedFormat || lona_format_1.SERIALIZATION_FORMAT.JSON;
            let value = lona_logic_1.convertLogic(JSON.stringify(node.parsed), embeddedFormat, {
                sourceFormat: options.sourceFormat,
                filePath: options.filePath,
            });
            // Prettify embedded JSON
            if (embeddedFormat === 'json') {
                value = JSON.stringify(JSON.parse(value), null, 2);
            }
            node.value = value;
            delete node.parsed;
        }
        return node;
    });
    return toMarkdown_1.default(encodedTokensAst);
}
exports.print = print;
